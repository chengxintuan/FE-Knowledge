# 类型

运行时类型是代码实际执行过程中我们用到的类型。所有的类型数据都会属于7个类型之一。从变量、参数、返回值到表达式中间结果，任何 JS 代码运行过程中产生的数据，都具有运行时类型。

这7种数据类型，分别是：

```js
Undefined
Null
Boolean
String
Number
Symbol
Object
```

这里将重新学习一下这些类型。

<br/>

## Undefined、Null

Undefined 类型表示未定义，它的类型只有一个值，就是 undefined。任何变量在赋值前是 Undefined类型、值为 undefined。

由于 undefined 不是一个关键字，这是 JS 语言公认的设计失误之一，所以，我们为了避免无意中被篡改，建议使用 void 0 来获取undefined值。

Null 类型也只有一个值，就是 null，它的语义表示空值，与 undefined 不同，null 是 JS 关键字，所以在任何代码中，你都可以放心用 null 关键字来获取 null 值。

<br/>

## Boolean

Boolean 类型有两个值， true 和 false，它用于表示逻辑意义上的真和假，同样有关键字 true 和 false 来表示两个值。

<br/>

## String

String 用于表示文本数据。String 有最大长度是 2^53 - 1，值得注意的是，这个最大长度，取决于字符串的编码长度。

String 的意义并非“字符串”，而是字符串的 UTF16 编码，我们字符串的操作 charAt、charCodeAt、length 等方法针对的都是 UTF16 编码。

关于 Unicode 及 UTF16 ，[文末](#字符编码)会有专门的介绍。

JavaScript 中的字符串是永远无法变更的，一旦字符串构造出来，无法用任何方式改变字符串的内容，所以字符串具有值类型的特征。

<br/>

## Number

Number类型表示我们通常意义上的“数字”。

JS 中的 Number 类型有 18437736874454810627(即2^64-2^53+3) 个值。

JS 中的 Number 类型基本符合 IEEE 754-2008 规定的双精度浮点数规则，但是JavaScript为了表达几个额外的语言场景（比如不让除以0出错，而引入了无穷大的概念），规定了几个例外情况：

1. NaN，占用了 9007199254740990，这原本是符合IEEE规则的数字；
2. Infinity，无穷大；
3. -Infinity，负无穷大。

另外，值得注意的是，JavaScript中有 +0 和 -0，在加法类运算中它们没有区别，但是除法的场合则需要特别留意区分。区分 +0 和 -0 的方式，正是检测 1/x 是 Infinity 还是 -Infinity。

根据双精度浮点数的定义，Number类型中有效的整数范围是-0x1fffffffffffff至0x1fffffffffffff，所以Number无法精确表示此范围外的整数。

同样根据浮点数的定义，非整数的Number类型无法用 ==（===也不行） 来比较，一段著名的代码，为什么在JavaScript中，0.1+0.2不能=0.3，这是因为0.1转换成二进制数是 0.0001100110011...。

所以，非整数的Number类型的比较，应该使用 JS 提供的最小精度值：

```js
console.log( Math.abs(0.1 + 0.2 - 0.3) <= Number.EPSILON);  // TRUE
```

检查等式左右两边差的绝对值是否小于最小精度，才是正确的比较浮点数的方法。这段代码结果就是 true 了。

<br/>

## Symbol

Symbol 是 ES6 中引入的新类型，它是一切非字符串的对象key的集合，在ES6规范中，整个对象系统被用Symbol 重塑。

Symbol 可以具有字符串类型的描述，但是即使描述相同，Symbol也不相等。

我们创建 Symbol 的方式是使用全局的 Symbol 函数。例如：`var mySymbol = Symbol("my symbol");`

一些标准中提到的 Symbol，可以在全局的 Symbol 函数的属性中找到。例如，我们可以使用 `Symbol.iterator` 来自定义 `for…of `在对象上的行为：

```js
var o = new Object
  o[Symbol.iterator] = function() {
    var v = 0
    return {
      next: function() {
      return { value: v++, done: v > 10 }
    }
  }
};
for(var v of o)
console.log(v); // 0 1 2 3 ... 9
```

代码中我们定义了iterator之后，用for(var v of o)就可以调用这个函数，然后我们可以根据函数的行为，产生一个for…of的行为。

这些标准中被称为“众所周知”的 Symbol，也构成了语言的一类接口形式。它们允许编写与语言结合更紧密的 API。

<br/>

## Object

Object 是 JavaScript 中最复杂的类型，也是 JavaScript 的核心机制之一。Object表示对象的意思，它是一切有形和无形物体的总称。

在 JS 中，对象的定义是“属性的集合”。属性分为数据属性和访问器属性，二者都是key-value结构，key可以是字符串或者 Symbol类型。

提到对象，我们必须要提到一个概念：类。

因为 C++ 和 Java 的成功，在这两门语言中，每个类都是一个类型，二者几乎等同，以至于很多人常常会把 JS 的“类”与类型混淆。

事实上，JavaScript 中的“类”仅仅是运行时对象的一个私有属性，而 JS 中是无法自定义类型的。

JS 中的几个基本类型，都在对象类型中有一个“亲戚”。它们是：

```js
Number
String
Boolean
Symbol
```

所以，我们必须认识到 3 与 new Number(3) 是完全不同的值，它们一个是 Number 类型， 一个是对象类型。

Number、String和Boolean，三个构造器是两用的，当跟 new 搭配时，它们产生对象，当直接调用时，它们表示强制类型转换。

Symbol 函数比较特殊，直接用 new 调用它会抛出错误，但它仍然是 Symbol 对象的构造器。

JS 语言设计上试图模糊对象和基本类型之间的关系，我们日常代码可以把对象的方法在基本类型上使用，比如：

```js
console.log("abc".charAt(0)); //a
```

甚至我们在原型上添加方法，都可以应用于基本类型，比如以下代码，在 Symbol 原型上添加了hello方法，在任何 Symbol 类型变量都可以调用。

```js
Symbol.prototype.hello = () => console.log("hello");
var a = Symbol("a");
console.log(typeof a); //symbol，a并非对象
a.hello(); //hello，有效
```

为什么给对象添加的方法能用在基本类型上？答案就是. 运算符提供了装箱操作，它会根据基础类型构造一个临时对象，使得我们能在基础类型上调用对应对象的方法。

关于装箱操作，这就是接下来要重点介绍的类型转换。

<br/>

## typeof vs instanceof

提到类型，就不得不提下typeof 跟 instanceof。

typeof 对于原始类型来说，除了 null 都可以显示正确的类型。

```js
typeof 1 // 'number'
typeof '1' // 'string'
typeof undefined // 'undefined'
typeof true // 'boolean'
typeof Symbol() // 'symbol'
```

typeof 对于对象来说，除了函数都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型。

如果我们想判断一个对象的正确类型，这时候可以考虑使用 instanceof，因为内部机制是通过原型链来判断的。

instanceof运算符用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置

但instanceof 也不是百分百可靠。看这个例子：

```js
class PrimitiveString {
  static [Symbol.hasInstance](x) {
    return typeof x === 'string'
  }
}
console.log('hello world' instanceof PrimitiveString) // true
```

Symbol.hasInstance 允许我们自定义 instanceof 的行为。

<br/>

# 类型转换

讲完了基本类型，我们来介绍一个现象：类型转换。

<br/>

## == 运算

因为JS是弱类型语言，所以类型转换发生非常频繁，大部分我们熟悉的运算都会先进行类型转换。大部分类型转换符合人类的直觉，“ == ”运算除外。因为试图实现跨类型的比较，“ == ”运算的规则复杂到几乎没人可以记住。

虽然==的行为很复杂，但是归根结底，类型不同的变量比较时 == 运算只有三条规则：

1. undefined与null相等；
2. 字符串和bool都转为数字再比较；
3. 对象转换成基础类型再比较。

这样我们就可以理解一些不太符合直觉的例子了，比如：

```js
false == '0' // true
true == 'true' // false
[] == 0 // true
[] == false // true
new Boolean('false') == false // false
```

这里不太符合直觉的有两点：

1. 即使字符串与boolean比较，也都要转换成数字；
2. 对象如果转换成了基础类型跟等号另一边类型恰好相同，则不需要转换成数字。

此外，== 的行为也经常跟if的行为（转换为boolean）混淆。总之，仅在确认 == 发生在Number和String类型之间时使用。

如果你觉得麻烦的话，这里提供了流程图：

<br/>
<img src="https://github.com/jiangxia/FE-Knowledge/raw/master/images/5.png">
<br/>

下面看一个典型的例子：为什么`[] == ![]`？分析如下：

```js
[] == ![]
↓
[] == false
↓
"" == false
↓
0 == false
↓
0 == 0
```

“ == ”运算属于设计失误，并非语言中有价值的部分，建议使用 === 比较。

幸好的是，实际上大部分类型转换规则是非常简单的，如下表所示：

|  | Null | Undefined | Boolean(true) | Boolean(false) | Number | String | Symbol | Object |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| Boolean | FALSE | FALSE | -- | -- | 当数字为0或NaN时为false | 当字符串为""时为false | TRUE | TRUE |
| Number | 0 | NaN | 1 | 0 | -- | StringToNumber | TypeError | 拆箱操作 |
| String | "null" | "undefined" | "true" | "false" | NumberToString | -- | TypeError | 拆箱操作 |
| Object | TypeError | TypeError | 装箱转换 | 装箱转换 | 装箱转换 | 装箱转换 | 装箱转换 | -- |


从表格中不难发现，JS的类型转换，只有4种，分别是：

1. 转换为布尔值
2. 转换为数字
3. 转换为字符串
4. 转换为对象


其中，“转换为数字”跟“转换为字符串”主要发生在字符串跟数字之间。我们逐一分析。

<br/>

## 转Boolean

在条件判断时，除了 undefined， null， false， NaN， ''， 0， -0，其他所有值都转为 true，包括所有对象。

<br/>

## StringToNumber

字符串到数字的类型转换，存在一个语法结构，类型转换支持十进制、二进制、八进制和十六进制，比如：

```js
30
0b111
0o13
0xFF
```

此外，JavaScript支持的字符串语法还包括正负号科学计数法，可以使用大写或者小写的e来表示：

```js
1e3
-1e-2
```

需要注意的是，parseInt 和 parseFloat 并不使用这个转换，所以支持的语法跟这里不尽相同。

在不传入第二个参数的情况下，parseInt只支持16进制前缀“0x”，而且会忽略非数字字符，也不支持科学计数法。建议传入parseInt的第二个参数。

parseFloat则直接把原字符串作为十进制来解析，它不会引入任何的其他进制。

多数情况下，Number 是比 parseInt 和 parseFloat 更好的选择。

<br/>

## NumberToString

在较小的范围内，数字到字符串的转换是完全符合你直觉的十进制表示。当Number绝对值较大或者较小时，字符串表示则是使用科学计数法表示的。这是为了保证产生的字符串不会过长。

<br/>

## 装箱转换

每一种基本类型Number、String、Boolean、Symbol在对象中都有对应的类，所谓装箱转换，正是把基本类型转换为对应的对象，它是类型转换中一种相当重要的种类。

装箱机制会频繁产生临时对象，在一些对性能要求较高的场景下，我们应该尽量避免对基本类型做装箱转换。

使用内置的 Object 函数，我们可以在 JS 代码中显式调用装箱能力。

```js
var symbolObject = Object(Symbol("a"));
console.log(typeof symbolObject); //object
console.log(symbolObject instanceof Symbol); //true
console.log(symbolObject.constructor == Symbol); //true
```

每一类装箱对象皆有私有的 Class 属性，这些属性可以用 Object.prototype.toString 获取：

```js
var symbolObject = Object(Symbol("a"));
console.log(Object.prototype.toString.call(symbolObject)); //[object Symbol]
```

在 JS 中，没有任何方法可以更改私有的 Class 属性，因此Object.prototype.toString 是可以准确识别对象对应的基本类型的方法，它比 instanceof 更加准确。

<br/>

## 拆箱转换

在JavaScript标准中，规定了 ToPrimitive 函数，它是对象类型到基本类型的转换（即拆箱转换）。

对象到 String 和 Number 的转换都遵循“先拆箱再转换”的规则。通过拆箱转换，把对象变成基本类型，再从基本类型转换为对应的 String 或者 Number。

拆箱转换会尝试调用 valueOf 和 toString 来获得拆箱后的基本类型。如果valueOf 和 toString都不存在，或者没有返回基本类型，则会产生类型错误 TypeError。

```js
var o = {
  valueOf: () => {
    console.log ('valueOf');
    return {};
  },
  toString: () => {
    console.log ('toString');
    return {};
  },
};
o * 2;
// valueOf
// toString
// TypeError
// 先执行了valueOf，接下来是toString，最后抛出了一个TypeError，这就说明了这个拆箱转换失败了
```

到 String 的拆箱转换会优先调用 toString。我们把刚才的运算从o*2换成 String(o)，那么你会看到调用顺序就变了。

```js
var o = {
  valueOf: () => {
    console.log ('valueOf');
    return {};
  },
  toString: () => {
    console.log ('toString');
    return {};
  },
};
String (o);
// toString
// valueOf
// TypeError
```

在 ES6 之后，还允许对象通过显式指定 Symbol.toPrimitive 来覆盖原有的行为。

```js
var o = {
  valueOf: () => {
    console.log ('valueOf');
    return {};
  },
  toString: () => {
    console.log ('toString');
    return {};
  },
};
o[Symbol.toPrimitive] = () => {
  console.log ('toPrimitive');
  return 'hello';
};
console.log (o + '');
// toPrimitive
// hello
```

<br/>

## 四则运算符

加法运算符不同于其他几个运算符，它有以下几个特点：

1. 运算中其中一方为字符串，那么就会把另一方也转换为字符串
2. 如果一方不是字符串或者数字，那么会将它转换为数字或者字符串

```js
1 + '1' // '11'
true + true // 2
4 + [1,2,3] // "41,2,3"
```

如果你对于答案有疑问的话，请看解析：

1. 对于第一行代码来说，触发特点一，所以将数字 1 转换为字符串，得到结果 '11'
2. 对于第二行代码来说，触发特点二，所以将 true 转为数字 1
3. 对于第三行代码来说，触发特点二，所以将数组通过 toString 转为字符串 1,2,3，得到结果 41,2,3

另外对于加法还需要注意这个表达式 'a' + + 'b'

```js
'a' + + 'b' // -> "aNaN"
```

因为 + 'b' 等于 NaN，所以结果为 "aNaN"，你可能也会在一些代码中看到过 + '1' 的形式来快速获取 number 类型。

那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。

```js
4 * '3' // 12
4 * [] // 0
4 * [1, 2] // NaN
```

<br/>

## 比较运算符

1. 如果是对象，先进行拆箱操作。
2. 如果是字符串，就通过 unicode 字符索引来比较

```js
let a = {
  valueOf() {
    return 0
  },
  toString() {
    return '1'
  }
}
a > -1 // true
```

在以上代码中，因为 a 是对象，所以会通过 valueOf 转换为原始类型再比较值。

<br/>

# 规范类型

除了这七种基础类型，还有一些语言的实现者更关心的规范类型。

1. List 和 Record： 用于描述函数传参过程。
2. Set：主要用于解释字符集等。
3. Completion Record：用于描述异常、跳出等语句执行过程。
4. Reference：用于描述对象属性访问、delete等。
5. Property Descriptor：用于描述对象的属性。
6. Lexical Environment 和 Environment Record：用于描述变量和作用域。
7. Data Block：用于描述二进制数据。

这些类型，对于我们开发者而言是用不到的，却对我们理解 JS 语言特性有非常大的作用。后续会有相应的介绍。

<br/>

# 字符编码

计算机内部，所有信息最终都是一个二进制值。

每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从00000000到11111111。

上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。

ASCII 码规定，最前面的一位统一规定为0，只占用了一个字节的后面7位，一共规定了128个字符的编码。

英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。

但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。

至于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。所以就出现了其他编码方式，比如简体中文常见的编码方式是 GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号。

需要注意的是，GB类的汉字编码与 Unicode 和 UTF-8 是毫无关系的。

编码方式的不同，最大的问题就是容易出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。

可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字都表示的，这是一种所有符号的编码。

常见的UTF-8、UTF-16 是 Unicode 的实现方式。关于 UTF-8，可以见 [资料](http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html) 。

你可能会好奇：JS 使用哪一种编码？

JS 语言采用Unicode字符集，但是只支持一种编码方法。这种编码既不是UTF-16，也不是UTF-8，更不是UTF-32，而是UCS-2（使用2个字节表示已经有码点的字符）！

UTF-16 跟 UCS-2的关系，简单说，就是UTF-16取代了UCS-2，或者说UCS-2整合进了UTF-16。所以，现在只有UTF-16，没有UCS-2。

之所以 JS 不选择更高级的UTF-16，是因为在 JS 语言出现的时候，还没有UTF-16编码。详见[资料](http://www.ruanyifeng.com/blog/2014/12/unicode.html) 。

综上，可以得出两个结论：

1. JS 采用 Unicode 字符集
2. 只支持16位的UTF-16编码，不支持32位

这导致的结果就是，JS 操作 String 时，只对2字节的码点有效。类似的方法有：

```js
String.prototype.replace()
String.prototype.substring()
String.prototype.slice()
String.prototype.charAt()
String.prototype.charCodeAt()
```

要正确处理4字节的码点，可以使用ES6提供的新特性。类似的方法有：

```js
String.fromCodePoint()：从Unicode码点返回对应字符
String.prototype.codePointAt()：从字符返回对应的码点
String.prototype.at()：返回字符串给定位置的字符
```

细节这里就不赘述，详见[资料](http://www.ruanyifeng.com/blog/2014/12/unicode.html) 。

<br/>

# 结语

在本篇文章中，我们介绍了 JS 运行时的类型系统。

有一个说法是：程序 = 算法 + 数据结构，运行时类型包含了所有 JS 执行时所需要的数据结构的定义，所以我们要对它格外重视。