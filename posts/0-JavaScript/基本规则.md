# 全局结构

## 脚本和模块

JavaScript有两种源文件，一种叫做脚本，一种叫做模块(ES6才有的)。

脚本是具有主动性的JavaScript代码段，是控制宿主完成一定任务的代码。

而模块是被动性的JavaScript代码段，只能由import引入执行，是等待被调用的库。

实际上模块和脚本之间的区别仅仅在于是否包含 import 和 export。

脚本跟模块的关系如下：

![images](https://github.com/jiangxia/FE-Knowledge/raw/master/images/2.png)

现代浏览器可以支持用script标签引入模块或者脚本，如果要引入模块，必须给script标签添加type="module"，否则抛错。

这里先讲import声明和export声明，语句会有专门的讲解。

<br/>

### import声明

import声明有两种用法，一个是直接import一个模块，另一个是带from的import，它能引入模块里的一些信息。

```js
import "mod"; //引入一个模块，但无法引用它的任何信息
import v from "mod"; //把模块默认的导出值放入变量v
```

带from的import细分又有三种用法，我们可以分别看下例子：

```js
import x from "./a.js" // 引入模块中导出的默认值。
import {a as x, modify} from "./a.js"; // 引入模块中的变量。
import * as x from "./a.js" // 把模块中所有的变量以类似对象属性的方式引入。
```

第一种方式还可以跟后两种组合使用。

```js
import d, {a as x, modify} from "./a.js"
import d, * as x from "./a.js"
```

语法要求不带as的默认值永远在最前。注意，这里的变量实际上仍然可以受到原来模块的控制。

<br/>

### export声明

与import相对， export 声明承担的是导出的任务。

模块中导出变量的方式有两种：

- 独立使用export声明，也就是一个export关键字加上变量名列表，例如：export {a, b, c};
- 直接在声明型语句前添加export关键字，这里的export可以加在任何声明性质的语句之前，整理如下：var、function (含async和generator)、class、let、const

export 有两种特殊用法： export default 、 export from 。


**export default**

export default 表示导出一个默认变量值，它可以用于function和class。

这里导出的变量是没有名称的，可以使用import x from "./a.js"这样的语法，在模块中引入。

本质上， export default 就是输出一个叫做default的变量或方法，所以export default后面不能再跟变量声明语句，但可以将一个值写在export default之后，import时系统允许你为它取任意名字。([参考资料](http://es6.ruanyifeng.com/#docs/module#export-default-%E5%91%BD%E4%BB%A4))


**export from**

在import语句前无法加入export，但是我们可以直接使用 export from 语法。

```js
export a from "a.js"
```


## 函数体

JavaScript引擎除了执行脚本和模块之外，还可以执行函数。而函数体跟脚本和模块有一定的相似之处，所以将函数体放在这里讲。

函数体其实也是一个语句的列表。跟脚本和模块比起来，函数体中的语句列表中多了return语句可以用。

函数体实际上有四种，分别是普通函数体、异步函数体、生成器函数体、异步生成器函数体。

普通函数体，例如：

```js
function foo(){
  //Function body
}
```

异步函数体，例如：

```js
async function foo(){
  //Function body
}
```

生成器函数体，例如：

```js
function *foo(){
  //Function body
}
```

异步生成器函数体，例如：

```js
async function *foo(){
  //Function body
}
```

这四种函数体的区别在于：能否使用await或者yield语句。

关于函数体、模块和脚本能使用的语句如下：

​
|类型|yield|await|return |import & export|
|--|--|--|--|--|
|普通函数体|×|×|√|×|
|异步函数体|×|√|√|×|
|生成器函数体|√|×|√|×|
|异步生成器函数体|√	|√|	√|	×|
|脚本|×|	×|	×|	×|
|模块|×|	×	|×	|√|
​
<br/>

# 全局机制

不理解预处理机制我们就无法理解var等声明类语句的行为，而不理解指令序言，我们就无法解释严格模式。

## 预处理

JS 执行前，会对脚本、模块和函数体中的语句进行预处理。预处理过程会提前处理var、函数声明、class、const和let这些语句，以确定其中变量的意义。

<br/>

### var声明

var声明永远作用于脚本、模块和函数体这个级别，在预处理阶段，不关心赋值的部分，只管在当前作用域声明这个变量。

来看个例子：

```js
var a = 1;
function foo() {
    console.log(a);
    if(false) {
        var a = 2;
    }
}
foo();
```

预处理过程在执行之前，所以有函数体级的变量a，就不会去访问外层作用域中的变量a了，而函数体级的变量a此时还没有赋值，所以打印出undefined。

值得注意的是，我们知道if(false)中的代码永远不会被执行，但是预处理阶段并不管这个，var的作用能够穿透一切语句结构，它只认脚本、模块和函数体三种语法结构。所以这里才打印出undefined。

var 声明要注意with语句，with语句会让变量在预处理阶段和执行阶段被当做两个不同变量，这也是为什么建议不要使用with语句的原因。

再看个例子：

```js
var a = 1;
function foo() {
    var o= {a:3}
    with(o) {
        var a = 2;
    }
    console.log(o.a);
    console.log(a);
}
foo();
```

在这个例子中，我们引入了with语句，我们用with(o)创建了一个作用域，并把o对象加入词法环境，在其中使用了`var a = 2;`语句。

在预处理阶段，只认var中声明的变量，所以同样为foo的作用域创建了a这个变量，但是没有赋值。

在执行阶段，当执行到var a = 2时，作用域变成了with语句内，这时候的a被认为访问到了对象o的属性a，所以最终执行的结果，我们得到了2和undefined。

这个行为是JavaScript公认的设计失误之一，一个语句中的a在预处理阶段和执行阶段被当做两个不同的变量，严重违背了直觉，但是今天，在JavaScript设计原则“don’t break the web”之下，已经无法修正了，所以你需要特别注意。

<br/>

### function声明

在全局（脚本、模块和函数体），function声明表现跟var相似。不同之处在于，function声明不但在作用域中加入变量，还会给它赋值。

来看个例子：

```js
console.log(a) // ƒ a() {}
function a() {}
var a = 1
```

对于上述代码，打印结果会是 ƒ a() {}，即使变量声明在函数之后，这也说明了函数会被提升，并且优先于变量提升。

function声明出现在if等语句中的情况有点复杂，它仍然作用于脚本、模块和函数体级别，在预处理阶段，仍然会产生变量，但如果if为false，它不会被提前赋值。

看个例子：

```js
console.log(foo);
if(true) {
    function foo(){
​
    }
}
```

这说明function在预处理阶段仍然发生了作用，在作用域中产生了变量，没有产生赋值，赋值行为发生在了执行阶段。

出现在if等语句中的function，在if创建的作用域中仍然会被提前，产生赋值效果。

如果把代码稍微改一下：

```js
console.log(foo);
if(false) {
    function foo(){
    }
}
```

这里打印的是undefined。说明赋值发生在执行过程。

<br/>

### class声明

class声明在全局的行为跟function和var都不一样。

class声明也是会被预处理的，但在class声明之前使用class名，会抛错，这是因为暂时性死区。

class的声明作用不会穿透if等语句结构，所以只有写在全局环境才会有声明作用。

看个例子：

```js
if (true) {
  class B{}
}
console.log(B);
```

## 指令序言机制

JS的指令序言是只有一个字符串直接量的表达式语句，它只能出现在脚本、模块和函数体的最前面。

use strict是JavaScript标准中规定的唯一一种指令序言，但是设计指令序言的目的是，留给JS的引擎和实现者一些统一的表达方式，在静态扫描时指定JS代码的一些特性。

# * 模块化的演变

本篇文章提到了模块，我们不妨了解下模块化的发展过程。

使用一个技术肯定是有原因的，那么使用模块化可以给我们带来以下好处：

1. 解决命名冲突
2. 提供复用性
3. 提高代码可维护性

模块化经历了立即执行函数、AMD和CMD、CommonJS，直到ES6出现，规范了模块化的用法。以下我们逐一讲解。

## 立即执行函数

在早期，使用立即执行函数实现模块化是常见的手段，通过函数作用域解决了命名冲突、污染全局作用域的问题。

```js
(function(globalVariable){
   globalVariable.test = function() {}
   // ... 声明各种变量、函数都不会污染全局作用域
})(globalVariable)
```

## AMD 和 CMD

鉴于目前这两种实现方式已经很少见到，所以不再对具体特性细聊，只需要了解这两者是如何使用的。

```js
// AMD
define(['./a', './b'], function(a, b) {
  // 加载模块完毕可以使用
  a.do()
  b.do()
})
// CMD
define(function(require, exports, module) {
  // 加载模块
  // 可以把 require 写在函数体的任意地方实现延迟加载
  var a = require('./a')
  a.doSomething()
})
```

## CommonJS

CommonJS 最早是 Node 在使用，目前也仍然广泛使用，比如在 Webpack 中你就能见到它，当然目前在 Node 中的模块管理已经和 CommonJS 有一些区别了。

```js​
// a.js
module.exports = {
    a: 1
}
// or 
exports.a = 1
// b.js
var module = require('./a.js')
module.a // -> log 1
```

因为 CommonJS 还是会使用到的，所以这里会对一些疑难点进行解析。

先说 require 吧。

```js
var module = require('./a.js')
module.a 
// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，
// 重要的是 module 这里，module 是 Node 独有的一个变量
module.exports = {
    a: 1
}
// module 基本实现
var module = {
  id: 'xxxx', // 我总得知道怎么去找到他吧
  exports: {} // exports 就是个空对象
}
// 这个是为什么 exports 和 module.exports 用法相似的原因
var exports = module.exports 
var load = function (module) {
    // 导出的东西
    var a = 1
    module.exports = a
    return module.exports
};
// 然后当我 require 的时候去找到独特的
// id，然后将要使用的东西用立即执行函数包装下，over
```

另外虽然 exports 和 module.exports 用法相似，但是不能对 exports 直接赋值。因为 var exports = module.exports 这句代码表明了 exports 和 module.exports 享有相同地址，通过改变对象的属性值会对两者都起效，但是如果直接对 exports 赋值就会导致两者不再指向同一个内存地址，修改并不会对 module.exports 起效。

## ES6 Module


ES6 Module 是原生实现的模块化方案，与 CommonJS 有以下几个区别：

1. CommonJS 支持动态导入，也就是 require(${path}/xx.js)，ES6目前不支持，但是已有提案
2. CommonJS 是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响
3. CommonJS 在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是 ES6 Module 采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化
4. ES6 Module 会编译成 require/exports 来执行的

```js
// 引入模块 API
import XXX from './a.js'
import { XXX } from './a.js'
// 导出模块 API
export function a() {}
export default function() {}
```
​
# 总结

这篇文章中，我们介绍了一部分语法的基本规则。

我们首先介绍了 JS 语法的全局结构，JavaScript有两种源文件，一种叫做脚本，一种叫做模块。介绍完脚本和模块的基础概念，我们再来把它们往下分，脚本中可以包含语句。模块中可以包含三种内容：import声明，export声明和语句。

最后，我介绍了两个 JS 语法的全局机制：预处理和指令序言。