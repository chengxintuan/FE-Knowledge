# 前言
react 是数据驱动的框架，也是目前前端最火的框架之一，学习react，我们照旧从应用维度跟设计维度进行学习。

<br/>

# 应用维度

<br/>

## 问题

> 从技术的应用维度看，首先考虑的是要解决什么问题，这是技术产生的原因。问题这层，用来回答“干什么用”。

<br/>

react 的诞生其实是要解决两个问题。UI细节问题问题 和 数据模型的问题。

### UI细节问题问题 

传统UI操作关注太多细节，jQuery虽然可以给我们提供了便捷的API，以及良好的浏览器兼容，但开发人员还是要手动去操作DOM，关注太多细节，不仅降低了开发效率，还可能引入BUG。

react 将开发人员从细节中解放出来，它始终整体“刷新”页面，无需关心细节。

举个例子：假设开发一个聊天的应用，​当有一条新消息到的时候，需要把新消息显示在页面上。

如果是局部刷新，首先我们要知道哪条是新消息，并为这条新消息创建一个节点，并把节点更新到页面的特定位置上

如果是整体刷新，只需要关心前后的状态，一个是两条消息，一个是三条消息，不需要关心哪条消息是新的，只需要把消息展示在UI上，不需要关心细节。

<br/>

### 数据模型的问题

前端开发，不可避免要面临数据管理的问题。

在react之前，前端管理数据的模型是MVC架构。

传统的MVC架构难以扩展和维护，当应用程序出现问题，很难知道是model还是view出现问题。

<br/>
<img src='https://github.com/jiangxia/FE-Knowledge/raw/master/images/96.png' width='600'>
<br/>

facebook 推出react的同时，也推出了flux架构。flux架构的最大特点就是单向数据流，Flux建立在react始终以状态驱动视图的基础上，不需要关心细节。

<br/>
<img src='https://github.com/jiangxia/FE-Knowledge/raw/master/images/97.png' width='600'>
<br/>

flux只是一个架构，开发者也发现flux并不好用，所以就诞生了redux，当然还有Mobx、dva，这块内容太多了，为此我将他抽离出来，请看[这里](https://github.com/jiangxia/FE-Knowledge/blob/master/posts/5-其他/数据管理学习笔记.md)。

<br/>


## 技术规范

> 技术被研发出来，人们怎么用它才能解决问题呢？这就要看技术规范，可以理解为技术使用说明书。技术规范，回答“怎么用”的问题，反映你对该技术使用方法的理解深度。

<br/>

### react组件

**react组件有四个特点：**

1. 由属性和状态得到一个view （ props + state = view ）
2. React 组件一般不提供方法，而是某种状态机
3. React组件可以理解为一个纯函数
4. 单向数据绑定

<br/>

**创建组件的步骤：**

1. 创建静态 UI
2. 考虑组件的状态组成：状态（state） 及 状态的改变（effect、reducer）
3. 考虑组件的交互方式：状态的触发（dispatch）

<br/>

**创建组件的原则**

1. 何时创建组件：单一职责原则
    - 每个组件只做一件事
    - 如果组件变得复杂，那么应该拆分成小组件
2. 数据状态管理：DRY原则
    - 能计算得到的状态就不要单独存储
    - 组件尽量无状态，所需数据通过 props 获取

<br/>

### 受控组件 VS 非受控组件

<br/>
<img src='https://github.com/jiangxia/FE-Knowledge/raw/master/images/98.jpg' width='800'>
<br/>

### 生命周期函数

生命周期函数指的是在某一个时刻组件会自动调用执行的函数

<br/>
<img src='https://github.com/jiangxia/FE-Knowledge/raw/master/images/86.jpg' width='800'>
<br/>

注意下update阶段，触发组件update有两种情况，props或者state的修改。

可以看到，这两种情况生命周期函数是有重合的。唯一的不同就是props改变时，会先调用 componentWillReceiveProps .

componentWillReceiveProps 的执行：

1. 一个组件要从父组件接受参数
2. 如果这个组件第一次存在于父组件中，不会执行
3. 如果这个组件之前已经存在于父组件中，才会执行

<br/>



<br/>

### 组件测试
jest
enzyme： https://airbnb.io/enzyme/

<br/>

## 最佳实践
> 最佳实践回答“怎么能用好”的问题，反映你实践经验的丰富程度。

<br/>

### 无状态组件

一个组件只有render函数时，可以定义为无状态组件，无状态组件就是一个函数，相比普通组件性能更高，因为他没有其他声明周期的方法。UI组件一般都可以定义为无状态组件。

### 高阶组件

<br/>



### react性能优化

**如何检测react性能**

在Chrome中监测react性能：在URL后加?react_perf，比如：localhost:3000/?react_perf

<br/>

**函数传递优化**

render中使用到的函数，最好都在constructor中使用bind进行绑定，这样可以提高性能。

<br/>



## 市场应用趋势
> 随着技术生态的发展，和应用问题的变迁，技术的应用场景和流行趋势会受到影响。这层回答“谁用，用在哪”的问题，反映你对技术应用领域的认识宽度。

<br/>

# 设计维度

<br/>

## 目标

> 为了解决用户的问题，技术本身要达成什么目标。这层定义“做到什么”。

<br/>

## 实现原理

> 为了达到设计目标，该技术采用了什么原理和机制。实现原理层回答“怎么做到”的问题。把实现原理弄懂，并且讲清楚，是技术人员的基本功。

<br/>

### render的执行
1. 当组件的state和props发生改变时，render函数就会重新执行
2. 父组件render函数被执行时，它的子组件的render函数都将被重新运行一次

<br/>


### this.setState

this.setState 背后有一个队列的机制，每次调用 setState ，都会塞到队列里面，通过队列可以高效更新 state ，setState 对状态的更新是异步的

<br/>

### applyMiddleWare

applyMiddleWare 的实现：
1. 拿到原生的store跟dispatch
2. 对dispatch做了一层扩展
3. 将原生store中的dispatch覆盖掉

<br/>


### 为什么需要VDOM？

**如果没有VDOM，state改变，如何渲染页面？**

最原始的做法：

1. state 数据
2. JSX 模板
3. 数据 + 模板 结合，生成真实DOM，来显示
4. state发生改变
5. 数据 + 模板 结合，生成真实DOM，替换原来的DOM

这样做的缺陷：

1. 第一次生成了完整的DOM片段
2. 第二次生成了完整的DOM片段
3. 第二次的DOM替换第一次的DOM，非常耗性能

**改进的做法：**

1. state 数据
2. JSX 模板
3. 数据 + 模板 结合，生成真实DOM，来显示
4. state发生改变
5. 数据 + 模板 结合，生成真实DOM，不直接替换原来的DOM
6. 新的DOM（DocumentFragment） 和 原始的DOM 做对比，找差异
7. 只替换有变动的DOM元素

这样做的缺陷：性能提升不明显，因为对比DOM也消耗了性能

**react的做法**

1. state 数据
2. JSX 模板
3. 数据 + 模板结合，生成VDOM（VDOM就是一个JS对象，用他来描述真实DOM）
4. 用VDOM，生成真实DOM，来显示
5. state发生改变
6. 生成新的VDOM （极大提升性能）
7. 比较原始VDOM和新的VDOM的区别 （极大提升性能）
8. 只替换有变动的DOM元素

优点：

1. 性能提升了
2. 跨端应用得以实现

<br/>

## 优劣局限

> 每种技术实现，都有其局限性，在某些条件下能最大化的发挥效能，缺少了某些条件则暴露出其缺陷。优劣局限层回答“做得怎么样”的问题。对技术优劣局限的把握，更有利于应用时总结最佳实践，是分析各种“坑”的基础。

<br/>


## 演进趋势

> 技术是在迭代改进和不断淘汰的。了解技术的前生后世，分清技术不变的本质，和变化的脉络，以及与其他技术的共生关系，能体现你对技术发展趋势的关注和思考。这层体现“未来如何”。

<br/>

### react16

react16新特性：

1. 新的核心算法Fiber
2. Render 可以返回数据、字符串
3. 错误处理机制

新版本带来的优化和新功能：

1. Portals 组件
2. 更好更快的服务端渲染
3. 体积更小，MIT协议