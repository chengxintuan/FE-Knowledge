<!-- TOC -->

- [导学](#导学)
  - [00 | 开篇词](#00--开篇词)
    - [什么是浏览器？](#什么是浏览器)
    - [浏览器的地位](#浏览器的地位)
    - [浏览器进化路线](#浏览器进化路线)
    - [为什么需要学习浏览器工作原理？](#为什么需要学习浏览器工作原理)
    - [应该如何学习前端呢？](#应该如何学习前端呢)
    - [前端技术的演进](#前端技术的演进)
- [宏观视角下的浏览器](#宏观视角下的浏览器)
  - [01丨Chrome架构：仅仅打开了1个页面，为什么有4个进程？](#01丨chrome架构仅仅打开了1个页面为什么有4个进程)
    - [进程和线程](#进程和线程)
      - [什么是并行处理](#什么是并行处理)
      - [线程 VS 进程](#线程-vs-进程)
      - [线程跟进程的关系](#线程跟进程的关系)
    - [单进程浏览器时代](#单进程浏览器时代)
    - [多进程浏览器时代](#多进程浏览器时代)
      - [早期多进程架构](#早期多进程架构)
      - [目前多进程架构](#目前多进程架构)
    - [未来面向服务的架构](#未来面向服务的架构)
    - [总结](#总结)
  - [02丨TCP协议：如何保证页面文件能被完整送达浏览器？](#02丨tcp协议如何保证页面文件能被完整送达浏览器)
  - [03丨HTTP请求流程：为什么很多站点第二次打开速度会很快？](#03丨http请求流程为什么很多站点第二次打开速度会很快)
  - [04丨导航流程：从输入URL到页面展示，这中间发生了什么？](#04丨导航流程从输入url到页面展示这中间发生了什么)
  - [05丨渲染流程（上）：HTML、CSS和JavaScript，是如何变成页面的？](#05丨渲染流程上htmlcss和javascript是如何变成页面的)
  - [06丨渲染流程（下）：HTML、CSS和JavaScript，是如何变成页面的？](#06丨渲染流程下htmlcss和javascript是如何变成页面的)
- [浏览器中的JavaScript执行机制](#浏览器中的javascript执行机制)
  - [07丨变量提升：JavaScript代码是按顺序执行的吗？](#07丨变量提升javascript代码是按顺序执行的吗)
  - [08丨调用栈：为什么JavaScript代码会出现栈溢出？](#08丨调用栈为什么javascript代码会出现栈溢出)
  - [09丨块级作用域：var缺陷以及为什么要引入let和const？](#09丨块级作用域var缺陷以及为什么要引入let和const)
  - [10丨作用域链和闭包：代码中出现相同的变量，JavaScript引擎是如何选择的？](#10丨作用域链和闭包代码中出现相同的变量javascript引擎是如何选择的)
  - [11丨this：从JavaScript执行上下文的视角讲清楚this](#11丨this从javascript执行上下文的视角讲清楚this)
- [V8工作原理](#v8工作原理)
  - [12丨栈空间和堆空间：数据是如何存储的？](#12丨栈空间和堆空间数据是如何存储的)
  - [13丨垃圾回收：垃圾数据是如何自动回收的？](#13丨垃圾回收垃圾数据是如何自动回收的)
  - [14丨编译器和解释器：V8是如何执行一段JavaScript代码的？](#14丨编译器和解释器v8是如何执行一段javascript代码的)
- [浏览器中的页面循环系统](#浏览器中的页面循环系统)
  - [15丨消息队列和事件循环：页面是怎么“活”起来的？](#15丨消息队列和事件循环页面是怎么活起来的)
  - [16丨WebAPI：setTimeout是如何实现的？](#16丨webapisettimeout是如何实现的)
  - [17丨WebAPI：XMLHttpRequest是怎么实现的？](#17丨webapixmlhttprequest是怎么实现的)
  - [18丨宏任务和微任务：不是所有任务都是一个待遇](#18丨宏任务和微任务不是所有任务都是一个待遇)
  - [19丨Promise：使用Promise，告别回调函数](#19丨promise使用promise告别回调函数)
  - [20丨async-await：使用同步的方式去写异步代码](#20丨async-await使用同步的方式去写异步代码)
- [浏览器中的页面](#浏览器中的页面)
  - [21丨Chrome开发者工具：利用网络面板做性能分析](#21丨chrome开发者工具利用网络面板做性能分析)
  - [22丨DOM树：JavaScript是如何影响DOM树构建的？](#22丨dom树javascript是如何影响dom树构建的)
  - [23丨渲染流水线：CSS如何影响首次加载时的白屏时间？](#23丨渲染流水线css如何影响首次加载时的白屏时间)
  - [24丨分层和合成机制：为什么CSS动画比JavaScript高效？](#24丨分层和合成机制为什么css动画比javascript高效)
  - [25丨页面性能：如何系统地优化页面？](#25丨页面性能如何系统地优化页面)
  - [26丨虚拟DOM：虚拟DOM和实际的DOM有何不同？](#26丨虚拟dom虚拟dom和实际的dom有何不同)
  - [27丨渐进式网页应用（PWA）：它究竟解决了Web应用的哪些问题？](#27丨渐进式网页应用pwa它究竟解决了web应用的哪些问题)
  - [28丨WebComponent：像搭积木一样构建Web应用](#28丨webcomponent像搭积木一样构建web应用)
- [浏览器中的网络](#浏览器中的网络)
  - [29丨HTTP-1：HTTP性能优化](#29丨http-1http性能优化)
  - [30｜HTTP-2：如何提升网络速度？](#30｜http-2如何提升网络速度)
  - [31｜HTTP-3：甩掉TCP、TLS的包袱，构建高效网络](#31｜http-3甩掉tcptls的包袱构建高效网络)
- [浏览器安全](#浏览器安全)
  - [32丨同源策略：为什么XMLHttpRequest不能跨域请求资源？](#32丨同源策略为什么xmlhttprequest不能跨域请求资源)
  - [33丨跨站脚本攻击（XSS）：为什么Cookie中有HttpOnly属性？](#33丨跨站脚本攻击xss为什么cookie中有httponly属性)
  - [34丨CSRF攻击：陌生链接不要随便点](#34丨csrf攻击陌生链接不要随便点)
  - [35丨安全沙箱：页面和系统之间的隔离墙](#35丨安全沙箱页面和系统之间的隔离墙)
  - [36丨HTTPS：让数据传输更安全](#36丨https让数据传输更安全)

<!-- /TOC -->
# 导学
## 00 | 开篇词

### 什么是浏览器？

浏览器是基于一套套标准的实现。外壳是浏览器，本质是标准的实现。

浏览器背后是标准，标准的背后是共识。

只有标准制定者跟开发者达成共识，才能推广。

近几年浏览器支持的标准越来越多，新的标准能够满足我们越来越多的项目需求。

<br/>
<img src='../../images/228.jpg' width='800'>
<br/>

也正是由于浏览器支持业务边界的增加，前端开发者出现疲于奔命的现象。

### 浏览器的地位

PC端浏览器的地位已经确立，移动端目前仍是军阀混战的阶段，浏览器、原生APP、各种新框架层出不穷，但是浏览器最终仍可能胜出，主要有两方面原因：

1. 开发基因，容易实现跨平台
2. 浏览器技术不断迭代，如渲染性能会逐渐接近原生

### 浏览器进化路线

未来的浏览器，有三个大的进化路线：

1. 应用程序 Web 化

视频、音频、游戏几大核心场景也都在往 Web 的使用场景切换

2. Web 应用移动化

Google 推出了 PWA 方案来整合 Web 和本地程序各自的优势

3. Web 操作系统化

一是利用 Web 技术构建一个纯粹的操作系统，如 ChromeOS；

二是浏览器的底层结构往操作系统架构方向发展

也就是说，浏览器是披着应用外衣的小型操作系统，浏览器已经逐步演化成了操作系统之上的“操作系统”。


### 为什么需要学习浏览器工作原理？

1. 准确评估 Web 开发项目的可行性
2. 从更高维度审视页面
3. 在快节奏的技术迭代中把握本质

一、关于从更高纬度审视页面

如果你把浏览器当成黑盒处理，也可以写前端代码，也可以使用很多最佳实践的策略来优化代码，这就如同不了解操作系统的工作原理同样可以在操作系统上写应用一样。

但如果你理解了这个黑盒子是如何工作的，那情况就不同了。你可以站在更高的维度审视你的项目，通过全视野快速定位项目中不合理的地方。比如，首屏的显示就涉及了 DNS、HTTP、DOM 解析、CSS 阻塞、JavaScript 阻塞等技术因素，其中一项没处理好就可能导致整个页面的延时。

而如果你了解了浏览器的工作原理，更加可以把这些知识点串成线，连成网，最终形成自己的知识体系，练就像专家一样思考问题、解决问题的能力。

二、在快节奏的技术迭代中把握本质

前端技术的发展，很大程度是依赖于浏览器的发展。

现阶段，浏览器功能以及整个前端的开发环境，不足以支撑日益增长的需求：脚本执行效率、页面渲染性能和开发工具链都有待完善。

谁能快速抓住变化，谁就能收获这波变化带来的红利。

了解浏览器的工作机制，可以更好梳理出来前端技术的发展脉络，更加深刻地理解当前的技术，同时清楚其不足之处，以及演化方向。

### 应该如何学习前端呢？

通过学习浏览器，搭建自己的知识体系

浏览器可以分为 5 个核心部分。

1. 浏览器架构设计
2. JS 引擎工作原理
3. 页面工作原理（事件循环系统、构建页面的核心流程）
4. 浏览器网络
5. 浏览器安全

不安全的地方，主要有三：
1. 网络传输过程中，数据可能会被串改或者被窃取
2. 操作系统层面，恶意web应用可以通过浏览器的漏洞来攻击操作系统
3. 浏览器层面，恶意程序获取浏览器页面的一些隐私信息

### 前端技术的演进

前端技术是如何针对这些核心诉求做演进的？

1. 脚本执行速度
2. 前端模块化
3. 渲染效率

一、首先是脚本执行速度问题。

比如针对 JavaScript 设计缺陷和执行效率的问题，可以从以下两个途径去解决：

- 不断修订和更新语言本身：ES6、ES7、ES8，或者 TypeScript
- 颠覆性地使用新的语言： WebAssembly。WebAssembly 需要经过编译器编译，所以体积小、执行速度快，使用它能大幅提升语言的执行效率，但是语言本身的完善，和生态的构建都是需要花很长时间来打造的。

二、其次是前端模块化开发。

比如，随着 Web 应用在各个领域的深入，Web 工程的复杂程度也越来越高，这就产生了模块化开发的需求，于是相应出现了 WebComponents 标准。我们所熟悉的 React 和 Vue 都在渐进地适应 WebComponents 标准，同时各种前端框架的最佳实践也会反过来影响 WebComponents 标准的制定。

如果理解了浏览器工作原理，那么你会对 WebComponents 中涉及的 Shawdow DOM、HTML Templates 等技术有更深刻的理解。

三、最后是渲染效率问题。

同样，如果理解浏览器的渲染流程，那么你应该知道目前页面的渲染依然存在很大缺陷，然后你就清楚如何避开这些问题，从而开发出更加高效的 Web 应用。

与此同时，Chrome 团队也在着手改善这些缺陷，比如正在开发的下一代布局方案 LayoutNG，还有渲染瘦身方案 Slim Paint，其目的都是让渲染变得更加简单和高效。

综上可以看出，触发这些改变的背后因素是当前技术制约了现实的需求，所以了解浏览器是如何工作的，能让你站在更高维度去理解前端。

# 宏观视角下的浏览器

## 01丨Chrome架构：仅仅打开了1个页面，为什么有4个进程？

浏览器有5个核心部分：

1. 浏览器架构设计
2. JS 引擎工作原理
3. 页面工作原理（事件循环系统、构建页面的核心流程）
4. 浏览器网络
5. 浏览器安全

而其中浏览器架构学习是关键，通过浏览器的多进程架构的学习，你就可以把这些分散的知识点串起来，组成一张网，从而让自己能站在更高的维度去理解 Web 应用。

打开一个页面，Chrome 启动了 4 个进程。为什么要启动这么多进程呢？在解答这个问题之前，我们需要了解一下进程的概念。

<br/>
<img src='../../images/220.png' width='600'>
<br/>

### 进程和线程

#### 什么是并行处理

计算机中的并行处理就是同一时刻处理多个任务，比如我们要计算下面这三个表达式的值，并显示出结果。

```
A = 1+2
B = 20/5
C = 7*8
```

单线程来处理，要分四步按照顺序分别执行这四个任务：三个计算任务，一个显示任务。

如果采用多线程，我们只需分“两步走”：第一步，使用三个线程同时执行前三个任务；第二步，再执行第四个显示任务。

通过对比分析，你会发现用单线程执行需要四步，而使用多线程只需要两步。因此，使用并行处理能大大提升性能。

#### 线程 VS 进程

首先，进程是线程的运行环境。

当启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫**进程**。

其次，线程不能单独存在，它需要进程来启动和管理。

进程中，可以使用单线程，也可以使用多线程。多线程并行处理能提升运算效率。

#### 线程跟进程的关系

1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃。
2. 线程之间共享进程中的数据。
3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。
4. 进程之间的内容相互隔离，进程间通信依赖IPC机制

### 单进程浏览器时代

单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等。

其实早在 2007 年之前，市面上浏览器都是单进程的。

单进程浏览器的架构如下图所示：

<br/>
<img src='../../images/223.png' width='800'>
<br/>

由于进程中的任意一线程执行出错，都会导致整个进程的崩溃。

如此多的功能模块运行在一个进程里，是导致单进程浏览器不稳定、不流畅和不安全的一个主要因素。

1. 不稳定

任一线程崩溃，都会导致整个浏览器崩溃。最典型的例子就是浏览器插件。

2. 不流畅

所有页面的渲染模块、JavaScript 执行环境以及插件都是运行在同一个页面线程，

这就意味着，某一个页面的模块运行时间过长，会导致整个浏览器失去响应，变卡顿。

3. 不安全

插件是 C/C++ 等代码编写，通过插件可以获取到操作系统的任意资源，当你在页面运行一个插件时也就意味着这个插件能完全操作你的电脑。如果是个恶意插件，那么它就可以释放病毒、窃取你的账号密码，引发安全性问题。

页面脚本，可以通过浏览器的漏洞来获取系统权限，这些脚本获取系统权限之后也可以对你的电脑做一些恶意的事情，同样也会引发安全问题。

### 多进程浏览器时代

#### 早期多进程架构

2008 年 Chrome 发布时的进程架构

<br/>
<img src='../../images/224.png' width='800'>
<br/>

渲染进程、插件进程独立出来，进程之间是通过 IPC 机制进行通信（如图中虚线部分）。

单进程浏览器时代最大的问题是，整个浏览器所有功能模块都是运行在同一个进程里，所以任一线程出了问题，直接影响到整个浏览器。

而多进程架构不存在这个问题，任一页面出了问题，只影响当前页面，不会影响整个浏览器。我们具体看看：

1. 解决不稳定的问题。由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面。

2. 解决不流畅的问题。JavaScript 运行在渲染进程中的，所以即使 JavaScript 阻塞了渲染进程，影响到的也只是当前的渲染页面，而并不会影响浏览器和其他页面。

3. 解决不安全的问题。安全沙箱可以看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据，例如你的文档和桌面。Chrome 把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。

#### 目前多进程架构

最新的 Chrome 进程架构：

<br/>
<img src='../../images/225.png' width='800'>
<br/>


从图中可以看出，最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。

目前多进程架构，对早期架构做了优化，增加了GPU 进程、网络进程。

下面我们来逐个分析下这几个进程的功能。

- 浏览器进程。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
- 渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
- GPU 进程。早期 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。
- 网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
- 插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

讲到这里，现在你应该就可以回答文章开头提到的问题了：仅仅打开了 1 个页面，为什么有 4 个进程？因为打开 1 个页面至少需要 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，共 4 个；如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。

不过凡事都有两面性，虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题：

- 更高的资源占用。因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。
- 更复杂的体系架构。浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。

对于上面这两个问题，Chrome 团队一直在寻求一种弹性方案，既可以解决资源占用高的问题，也可以解决复杂的体系架构的问题。

### 未来面向服务的架构

为了解决这些问题，在 2016 年，Chrome 官方团队使用“面向服务的架构”（简称SOA）的思想设计了新的 Chrome 架构。

也就是说 Chrome 整体架构会朝向现代操作系统所采用的“面向服务的架构” 方向发展，原来的各种模块会被重构成独立的服务。每个服务都可以在独立的进程中运行。

Chrome 最终要把 UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统底层服务，下面是 Chrome“面向服务的架构”的进程模型图：

<br/>
<img src='../../images/226.png' width='800'>
<br/>

目前 Chrome 正处在老的架构向服务化架构过渡阶段，这将是一个漫长的迭代过程。

Chrome 正在逐步构建 Chrome 基础服务，如果你认为 Chrome 是“便携式操作系统”，那么 Chrome 基础服务便可以被视为该操作系统的“基础”系统服务层。

同时 Chrome 还提供灵活的弹性架构，在强大性能设备上会以多进程的方式运行基础服务，但是如果在资源受限的设备上（如下图），Chrome 会将很多服务整合到一个进程中，从而节省内存占用。

<br/>
<img src='../../images/227.png' width='800'>
<br/>

### 总结

本文我主要是从 Chrome 进程架构的视角，分析了浏览器的进化史。

最初的浏览器都是单进程的，它们不稳定、不流畅且不安全，之后出现了 Chrome，创造性地引入了多进程架构，并解决了这些遗留问题。

随后 Chrome 试图应用到更多业务场景，如移动设备、VR、视频等，为了支持这些场景，Chrome 的架构体系变得越来越复杂，这种架构的复杂性倒逼 Chrome 开发团队必须进行架构的重构，最终 Chrome 团队选择了面向服务架构（SOA）形式，这也是 Chrome 团队现阶段的一个主要任务。

<br>

## 02丨TCP协议：如何保证页面文件能被完整送达浏览器？

## 03丨HTTP请求流程：为什么很多站点第二次打开速度会很快？
## 04丨导航流程：从输入URL到页面展示，这中间发生了什么？
## 05丨渲染流程（上）：HTML、CSS和JavaScript，是如何变成页面的？
## 06丨渲染流程（下）：HTML、CSS和JavaScript，是如何变成页面的？

# 浏览器中的JavaScript执行机制
## 07丨变量提升：JavaScript代码是按顺序执行的吗？
## 08丨调用栈：为什么JavaScript代码会出现栈溢出？
## 09丨块级作用域：var缺陷以及为什么要引入let和const？
## 10丨作用域链和闭包：代码中出现相同的变量，JavaScript引擎是如何选择的？
## 11丨this：从JavaScript执行上下文的视角讲清楚this

# V8工作原理
## 12丨栈空间和堆空间：数据是如何存储的？
## 13丨垃圾回收：垃圾数据是如何自动回收的？
## 14丨编译器和解释器：V8是如何执行一段JavaScript代码的？

# 浏览器中的页面循环系统
## 15丨消息队列和事件循环：页面是怎么“活”起来的？
## 16丨WebAPI：setTimeout是如何实现的？
## 17丨WebAPI：XMLHttpRequest是怎么实现的？
## 18丨宏任务和微任务：不是所有任务都是一个待遇
## 19丨Promise：使用Promise，告别回调函数
## 20丨async-await：使用同步的方式去写异步代码

# 浏览器中的页面
## 21丨Chrome开发者工具：利用网络面板做性能分析
## 22丨DOM树：JavaScript是如何影响DOM树构建的？
## 23丨渲染流水线：CSS如何影响首次加载时的白屏时间？
## 24丨分层和合成机制：为什么CSS动画比JavaScript高效？
## 25丨页面性能：如何系统地优化页面？
## 26丨虚拟DOM：虚拟DOM和实际的DOM有何不同？
## 27丨渐进式网页应用（PWA）：它究竟解决了Web应用的哪些问题？
## 28丨WebComponent：像搭积木一样构建Web应用

# 浏览器中的网络
## 29丨HTTP-1：HTTP性能优化
## 30｜HTTP-2：如何提升网络速度？
## 31｜HTTP-3：甩掉TCP、TLS的包袱，构建高效网络

# 浏览器安全
## 32丨同源策略：为什么XMLHttpRequest不能跨域请求资源？
## 33丨跨站脚本攻击（XSS）：为什么Cookie中有HttpOnly属性？
## 34丨CSRF攻击：陌生链接不要随便点
## 35丨安全沙箱：页面和系统之间的隔离墙
## 36丨HTTPS：让数据传输更安全
