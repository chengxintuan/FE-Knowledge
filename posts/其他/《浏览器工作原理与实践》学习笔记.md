<!-- TOC -->

- [导学](#导学)
  - [00 | 开篇词](#00--开篇词)
    - [什么是浏览器？](#什么是浏览器)
    - [浏览器的地位](#浏览器的地位)
    - [浏览器进化路线](#浏览器进化路线)
    - [为什么需要学习浏览器工作原理？](#为什么需要学习浏览器工作原理)
    - [应该如何学习前端呢？](#应该如何学习前端呢)
    - [前端技术的演进](#前端技术的演进)
- [宏观视角下的浏览器](#宏观视角下的浏览器)
  - [01丨Chrome架构：仅仅打开了1个页面，为什么有4个进程？](#01丨chrome架构仅仅打开了1个页面为什么有4个进程)
    - [进程和线程](#进程和线程)
      - [什么是并行处理](#什么是并行处理)
      - [线程 VS 进程](#线程-vs-进程)
      - [线程跟进程的关系](#线程跟进程的关系)
    - [单进程浏览器时代](#单进程浏览器时代)
    - [多进程浏览器时代](#多进程浏览器时代)
      - [早期多进程架构](#早期多进程架构)
      - [目前多进程架构](#目前多进程架构)
    - [未来面向服务的架构](#未来面向服务的架构)
    - [总结](#总结)
  - [02丨TCP协议：如何保证页面文件能被完整送达浏览器？](#02丨tcp协议如何保证页面文件能被完整送达浏览器)
    - [IP：把数据包送达目的主机](#ip把数据包送达目的主机)
    - [UDP：把数据包送达应用程序](#udp把数据包送达应用程序)
    - [TCP：把数据完整地送达应用程序](#tcp把数据完整地送达应用程序)
    - [总结](#总结-1)
  - [03丨HTTP请求流程：为什么很多站点第二次打开速度会很快？](#03丨http请求流程为什么很多站点第二次打开速度会很快)
    - [浏览器端发起 HTTP 请求流程](#浏览器端发起-http-请求流程)
      - [1 构建请求](#1-构建请求)
      - [2 查找缓存](#2-查找缓存)
      - [准备 IP 地址和端口](#准备-ip-地址和端口)
      - [等待 TCP 队列](#等待-tcp-队列)
      - [建立 TCP 连接](#建立-tcp-连接)
      - [发送 HTTP 请求](#发送-http-请求)
    - [服务器端处理 HTTP 请求流程](#服务器端处理-http-请求流程)
      - [返回请求](#返回请求)
      - [断开连接](#断开连接)
    - [问题解答](#问题解答)
      - [为什么很多站点第二次打开速度会很快？](#为什么很多站点第二次打开速度会很快)
      - [登录状态是如何保持的？](#登录状态是如何保持的)
    - [总结](#总结-2)
    - [学习技巧](#学习技巧)
  - [04丨导航流程：从输入URL到页面展示，这中间发生了什么？](#04丨导航流程从输入url到页面展示这中间发生了什么)
    - [1. 用户输入](#1-用户输入)
    - [2. URL 请求过程](#2-url-请求过程)
      - [重定向](#重定向)
      - [响应数据类型处理](#响应数据类型处理)
    - [3. 准备渲染进程](#3-准备渲染进程)
    - [4. 提交文档](#4-提交文档)
    - [5. 渲染阶段](#5-渲染阶段)
  - [05丨渲染流程（上）：HTML、CSS和JavaScript，是如何变成页面的？](#05丨渲染流程上htmlcss和javascript是如何变成页面的)
    - [构建 DOM 树](#构建-dom-树)
    - [样式计算](#样式计算)
      - [1. 把 CSS 转换为浏览器能够理解的结构](#1-把-css-转换为浏览器能够理解的结构)
      - [2. 转换样式表中的属性值，使其标准化](#2-转换样式表中的属性值使其标准化)
      - [3. 计算出 DOM 树中每个节点的具体样式](#3-计算出-dom-树中每个节点的具体样式)
    - [布局阶段](#布局阶段)
      - [1. 创建布局树](#1-创建布局树)
      - [2. 布局计算](#2-布局计算)
    - [总结](#总结-3)
  - [06丨渲染流程（下）：HTML、CSS和JavaScript，是如何变成页面的？](#06丨渲染流程下htmlcss和javascript是如何变成页面的)
    - [分层](#分层)
    - [图层绘制](#图层绘制)
    - [栅格化（raster）操作](#栅格化raster操作)
    - [合成和显示](#合成和显示)
    - [渲染流水线大总结](#渲染流水线大总结)
    - [相关概念](#相关概念)
      - [1. 更新了元素的几何属性（重排）](#1-更新了元素的几何属性重排)
      - [2. 更新元素的绘制属性（重绘）](#2-更新元素的绘制属性重绘)
      - [3. 直接合成阶段](#3-直接合成阶段)
  - [渲染小结](#渲染小结)
- [浏览器中的JavaScript执行机制](#浏览器中的javascript执行机制)
  - [07丨变量提升：JavaScript代码是按顺序执行的吗？](#07丨变量提升javascript代码是按顺序执行的吗)
  - [08丨调用栈：为什么JavaScript代码会出现栈溢出？](#08丨调用栈为什么javascript代码会出现栈溢出)
  - [09丨块级作用域：var缺陷以及为什么要引入let和const？](#09丨块级作用域var缺陷以及为什么要引入let和const)
  - [10丨作用域链和闭包：代码中出现相同的变量，JavaScript引擎是如何选择的？](#10丨作用域链和闭包代码中出现相同的变量javascript引擎是如何选择的)
  - [11丨this：从JavaScript执行上下文的视角讲清楚this](#11丨this从javascript执行上下文的视角讲清楚this)
- [V8工作原理](#v8工作原理)
  - [12丨栈空间和堆空间：数据是如何存储的？](#12丨栈空间和堆空间数据是如何存储的)
  - [13丨垃圾回收：垃圾数据是如何自动回收的？](#13丨垃圾回收垃圾数据是如何自动回收的)
  - [14丨编译器和解释器：V8是如何执行一段JavaScript代码的？](#14丨编译器和解释器v8是如何执行一段javascript代码的)
- [浏览器中的页面循环系统](#浏览器中的页面循环系统)
  - [15丨消息队列和事件循环：页面是怎么“活”起来的？](#15丨消息队列和事件循环页面是怎么活起来的)
  - [16丨WebAPI：setTimeout是如何实现的？](#16丨webapisettimeout是如何实现的)
  - [17丨WebAPI：XMLHttpRequest是怎么实现的？](#17丨webapixmlhttprequest是怎么实现的)
  - [18丨宏任务和微任务：不是所有任务都是一个待遇](#18丨宏任务和微任务不是所有任务都是一个待遇)
  - [19丨Promise：使用Promise，告别回调函数](#19丨promise使用promise告别回调函数)
  - [20丨async-await：使用同步的方式去写异步代码](#20丨async-await使用同步的方式去写异步代码)
- [浏览器中的页面](#浏览器中的页面)
  - [21丨Chrome开发者工具：利用网络面板做性能分析](#21丨chrome开发者工具利用网络面板做性能分析)
  - [22丨DOM树：JavaScript是如何影响DOM树构建的？](#22丨dom树javascript是如何影响dom树构建的)
  - [23丨渲染流水线：CSS如何影响首次加载时的白屏时间？](#23丨渲染流水线css如何影响首次加载时的白屏时间)
  - [24丨分层和合成机制：为什么CSS动画比JavaScript高效？](#24丨分层和合成机制为什么css动画比javascript高效)
  - [25丨页面性能：如何系统地优化页面？](#25丨页面性能如何系统地优化页面)
  - [26丨虚拟DOM：虚拟DOM和实际的DOM有何不同？](#26丨虚拟dom虚拟dom和实际的dom有何不同)
  - [27丨渐进式网页应用（PWA）：它究竟解决了Web应用的哪些问题？](#27丨渐进式网页应用pwa它究竟解决了web应用的哪些问题)
  - [28丨WebComponent：像搭积木一样构建Web应用](#28丨webcomponent像搭积木一样构建web应用)
- [浏览器中的网络](#浏览器中的网络)
  - [29丨HTTP-1：HTTP性能优化](#29丨http-1http性能优化)
  - [30｜HTTP-2：如何提升网络速度？](#30｜http-2如何提升网络速度)
  - [31｜HTTP-3：甩掉TCP、TLS的包袱，构建高效网络](#31｜http-3甩掉tcptls的包袱构建高效网络)
- [浏览器安全](#浏览器安全)
  - [32丨同源策略：为什么XMLHttpRequest不能跨域请求资源？](#32丨同源策略为什么xmlhttprequest不能跨域请求资源)
  - [33丨跨站脚本攻击（XSS）：为什么Cookie中有HttpOnly属性？](#33丨跨站脚本攻击xss为什么cookie中有httponly属性)
  - [34丨CSRF攻击：陌生链接不要随便点](#34丨csrf攻击陌生链接不要随便点)
  - [35丨安全沙箱：页面和系统之间的隔离墙](#35丨安全沙箱页面和系统之间的隔离墙)
  - [36丨HTTPS：让数据传输更安全](#36丨https让数据传输更安全)

<!-- /TOC -->
# 导学
## 00 | 开篇词

### 什么是浏览器？

浏览器是基于一套套标准的实现。外壳是浏览器，本质是标准的实现。

浏览器背后是标准，标准的背后是共识。

只有标准制定者跟开发者达成共识，才能推广。

近几年浏览器支持的标准越来越多，新的标准能够满足我们越来越多的项目需求。

<br/>
<img src='../../images/228.jpg' width='800'>
<br/>

也正是由于浏览器支持业务边界的增加，前端开发者出现疲于奔命的现象。

### 浏览器的地位

PC端浏览器的地位已经确立，移动端目前仍是军阀混战的阶段，浏览器、原生APP、各种新框架层出不穷，但是浏览器最终仍可能胜出，主要有两方面原因：

1. 开发基因，容易实现跨平台
2. 浏览器技术不断迭代，如渲染性能会逐渐接近原生

### 浏览器进化路线

未来的浏览器，有三个大的进化路线：

1. 应用程序 Web 化

视频、音频、游戏几大核心场景也都在往 Web 的使用场景切换

2. Web 应用移动化

Google 推出了 PWA 方案来整合 Web 和本地程序各自的优势

3. Web 操作系统化

一是利用 Web 技术构建一个纯粹的操作系统，如 ChromeOS；

二是浏览器的底层结构往操作系统架构方向发展

也就是说，浏览器是披着应用外衣的小型操作系统，浏览器已经逐步演化成了操作系统之上的“操作系统”。


### 为什么需要学习浏览器工作原理？

1. 准确评估 Web 开发项目的可行性
2. 从更高维度审视页面
3. 在快节奏的技术迭代中把握本质

一、关于从更高纬度审视页面

如果你把浏览器当成黑盒处理，也可以写前端代码，也可以使用很多最佳实践的策略来优化代码，这就如同不了解操作系统的工作原理同样可以在操作系统上写应用一样。

但如果你理解了这个黑盒子是如何工作的，那情况就不同了。你可以站在更高的维度审视你的项目，通过全视野快速定位项目中不合理的地方。比如，首屏的显示就涉及了 DNS、HTTP、DOM 解析、CSS 阻塞、JavaScript 阻塞等技术因素，其中一项没处理好就可能导致整个页面的延时。

而如果你了解了浏览器的工作原理，更加可以把这些知识点串成线，连成网，最终形成自己的知识体系，练就像专家一样思考问题、解决问题的能力。

二、在快节奏的技术迭代中把握本质

前端技术的发展，很大程度是依赖于浏览器的发展。

现阶段，浏览器功能以及整个前端的开发环境，不足以支撑日益增长的需求：脚本执行效率、页面渲染性能和开发工具链都有待完善。

谁能快速抓住变化，谁就能收获这波变化带来的红利。

了解浏览器的工作机制，可以更好梳理出来前端技术的发展脉络，更加深刻地理解当前的技术，同时清楚其不足之处，以及演化方向。

### 应该如何学习前端呢？

通过学习浏览器，搭建自己的知识体系

浏览器可以分为 5 个核心部分。

1. 浏览器架构设计
2. JS 引擎工作原理
3. 页面工作原理（事件循环系统、构建页面的核心流程）
4. 浏览器网络
5. 浏览器安全

不安全的地方，主要有三：
1. 网络传输过程中，数据可能会被串改或者被窃取
2. 操作系统层面，恶意web应用可以通过浏览器的漏洞来攻击操作系统
3. 浏览器层面，恶意程序获取浏览器页面的一些隐私信息

### 前端技术的演进

前端技术是如何针对这些核心诉求做演进的？

1. 脚本执行速度
2. 前端模块化
3. 渲染效率

一、首先是脚本执行速度问题。

比如针对 JavaScript 设计缺陷和执行效率的问题，可以从以下两个途径去解决：

- 不断修订和更新语言本身：ES6、ES7、ES8，或者 TypeScript
- 颠覆性地使用新的语言： WebAssembly。WebAssembly 需要经过编译器编译，所以体积小、执行速度快，使用它能大幅提升语言的执行效率，但是语言本身的完善，和生态的构建都是需要花很长时间来打造的。

二、其次是前端模块化开发。

比如，随着 Web 应用在各个领域的深入，Web 工程的复杂程度也越来越高，这就产生了模块化开发的需求，于是相应出现了 WebComponents 标准。我们所熟悉的 React 和 Vue 都在渐进地适应 WebComponents 标准，同时各种前端框架的最佳实践也会反过来影响 WebComponents 标准的制定。

如果理解了浏览器工作原理，那么你会对 WebComponents 中涉及的 Shawdow DOM、HTML Templates 等技术有更深刻的理解。

三、最后是渲染效率问题。

同样，如果理解浏览器的渲染流程，那么你应该知道目前页面的渲染依然存在很大缺陷，然后你就清楚如何避开这些问题，从而开发出更加高效的 Web 应用。

与此同时，Chrome 团队也在着手改善这些缺陷，比如正在开发的下一代布局方案 LayoutNG，还有渲染瘦身方案 Slim Paint，其目的都是让渲染变得更加简单和高效。

综上可以看出，触发这些改变的背后因素是当前技术制约了现实的需求，所以了解浏览器是如何工作的，能让你站在更高维度去理解前端。

# 宏观视角下的浏览器

## 01丨Chrome架构：仅仅打开了1个页面，为什么有4个进程？

浏览器有5个核心部分：

1. 浏览器架构设计
2. JS 引擎工作原理
3. 页面工作原理（事件循环系统、构建页面的核心流程）
4. 浏览器网络
5. 浏览器安全

而其中浏览器架构学习是关键，通过浏览器的多进程架构的学习，你就可以把这些分散的知识点串起来，组成一张网，从而让自己能站在更高的维度去理解 Web 应用。

打开一个页面，Chrome 启动了 4 个进程。为什么要启动这么多进程呢？在解答这个问题之前，我们需要了解一下进程的概念。

<br/>
<img src='../../images/220.png' width='800'>
<br/>

### 进程和线程

#### 什么是并行处理

计算机中的并行处理就是同一时刻处理多个任务，比如我们要计算下面这三个表达式的值，并显示出结果。

```
A = 1+2
B = 20/5
C = 7*8
```

单线程来处理，要分四步按照顺序分别执行这四个任务：三个计算任务，一个显示任务。

如果采用多线程，我们只需分“两步走”：第一步，使用三个线程同时执行前三个任务；第二步，再执行第四个显示任务。

通过对比分析，你会发现用单线程执行需要四步，而使用多线程只需要两步。因此，使用并行处理能大大提升性能。

#### 线程 VS 进程

首先，进程是线程的运行环境。

当启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫**进程**。

其次，线程不能单独存在，它需要进程来启动和管理。

进程中，可以使用单线程，也可以使用多线程。多线程并行处理能提升运算效率。

#### 线程跟进程的关系

1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃。
2. 线程之间共享进程中的数据。
3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。
4. 进程之间的内容相互隔离，进程间通信依赖IPC机制

### 单进程浏览器时代

单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等。

其实早在 2007 年之前，市面上浏览器都是单进程的。

单进程浏览器的架构如下图所示：

<br/>
<img src='../../images/223.png' width='800'>
<br/>

由于进程中的任意一线程执行出错，都会导致整个进程的崩溃。

如此多的功能模块运行在一个进程里，是导致单进程浏览器不稳定、不流畅和不安全的一个主要因素。

1. 不稳定

任一线程崩溃，都会导致整个浏览器崩溃。最典型的例子就是浏览器插件。

2. 不流畅

所有页面的渲染模块、JavaScript 执行环境以及插件都是运行在同一个页面线程，

这就意味着，某一个页面的模块运行时间过长，会导致整个浏览器失去响应，变卡顿。

3. 不安全

插件是 C/C++ 等代码编写，通过插件可以获取到操作系统的任意资源，当你在页面运行一个插件时也就意味着这个插件能完全操作你的电脑。如果是个恶意插件，那么它就可以释放病毒、窃取你的账号密码，引发安全性问题。

页面脚本，可以通过浏览器的漏洞来获取系统权限，这些脚本获取系统权限之后也可以对你的电脑做一些恶意的事情，同样也会引发安全问题。

### 多进程浏览器时代

#### 早期多进程架构

2008 年 Chrome 发布时的进程架构

<br/>
<img src='../../images/224.png' width='800'>
<br/>

渲染进程、插件进程独立出来，进程之间是通过 IPC 机制进行通信（如图中虚线部分）。

单进程浏览器时代最大的问题是，整个浏览器所有功能模块都是运行在同一个进程里，所以任一线程出了问题，直接影响到整个浏览器。

而多进程架构不存在这个问题，任一页面出了问题，只影响当前页面，不会影响整个浏览器。我们具体看看：

1. 解决不稳定的问题。由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面。

2. 解决不流畅的问题。JavaScript 运行在渲染进程中的，所以即使 JavaScript 阻塞了渲染进程，影响到的也只是当前的渲染页面，而并不会影响浏览器和其他页面。

3. 解决不安全的问题。安全沙箱可以看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据，例如你的文档和桌面。Chrome 把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。

#### 目前多进程架构

最新的 Chrome 进程架构：

<br/>
<img src='../../images/225.png' width='800'>
<br/>


从图中可以看出，最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。

目前多进程架构，对早期架构做了优化，增加了GPU 进程、网络进程。

下面我们来逐个分析下这几个进程的功能。

- 浏览器进程。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
- 渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
- GPU 进程。早期 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。
- 网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
- 插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

讲到这里，现在你应该就可以回答文章开头提到的问题了：仅仅打开了 1 个页面，为什么有 4 个进程？因为打开 1 个页面至少需要 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，共 4 个；如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。

不过凡事都有两面性，虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题：

- 更高的资源占用。因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。
- 更复杂的体系架构。浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。

对于上面这两个问题，Chrome 团队一直在寻求一种弹性方案，既可以解决资源占用高的问题，也可以解决复杂的体系架构的问题。

### 未来面向服务的架构

为了解决这些问题，在 2016 年，Chrome 官方团队使用“面向服务的架构”（简称SOA）的思想设计了新的 Chrome 架构。

也就是说 Chrome 整体架构会朝向现代操作系统所采用的“面向服务的架构” 方向发展，原来的各种模块会被重构成独立的服务。每个服务都可以在独立的进程中运行。

Chrome 最终要把 UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统底层服务，下面是 Chrome“面向服务的架构”的进程模型图：

<br/>
<img src='../../images/226.png' width='800'>
<br/>

目前 Chrome 正处在老的架构向服务化架构过渡阶段，这将是一个漫长的迭代过程。

Chrome 正在逐步构建 Chrome 基础服务，如果你认为 Chrome 是“便携式操作系统”，那么 Chrome 基础服务便可以被视为该操作系统的“基础”系统服务层。

同时 Chrome 还提供灵活的弹性架构，在强大性能设备上会以多进程的方式运行基础服务，但是如果在资源受限的设备上（如下图），Chrome 会将很多服务整合到一个进程中，从而节省内存占用。

<br/>
<img src='../../images/227.png' width='800'>
<br/>

### 总结

本文我主要是从 Chrome 进程架构的视角，分析了浏览器的进化史。

最初的浏览器都是单进程的，它们不稳定、不流畅且不安全，之后出现了 Chrome，创造性地引入了多进程架构，并解决了这些遗留问题。

随后 Chrome 试图应用到更多业务场景，如移动设备、VR、视频等，为了支持这些场景，Chrome 的架构体系变得越来越复杂，这种架构的复杂性倒逼 Chrome 开发团队必须进行架构的重构，最终 Chrome 团队选择了面向服务架构（SOA）形式，这也是 Chrome 团队现阶段的一个主要任务。

<br>

## 02丨TCP协议：如何保证页面文件能被完整送达浏览器？

互联网中的数据是通过数据包来传输的。如果发送的数据很大，那么该数据就会被拆分为很多小数据包来传输,并不是一个大的文件一次传输过来的。

数据包在传输过程中又有很大概率丢失或者出错。那么如何保证页面文件能被完整地送达浏览器呢？

这个问题，可以拆分成三个子问题：

1. 数据包如何送达主机
2. 主机如何将数据包转交给应用
3. 数据是如何被完整地送达应用程序

### IP：把数据包送达目的主机

数据包要在互联网上进行传输，就要符合网际协议（简称IP）标准。

互联网上不同的在线设备都有唯一的地址，这个地址称为 IP 地址。

如果要想把一个数据包从主机 A 发送给主机 B，那么在传输之前，数据包上会被附加上主机 B 的 IP 地址信息，这样在传输过程中才能正确寻址。

额外地，数据包上还会附加上主机 A 本身的 IP 地址，有了这些信息主机 B 才可以回复信息给主机 A。

这些附加的信息会被装进一个叫 IP 头的数据结构里。

IP 头是 IP 数据包开头的信息，包含 IP 版本、源 IP 地址、目标 IP 地址、生存时间等信息。

为了方便理解，我先把网络简单分为三层结构，如下图：

<br/>
<img src='../../images/229.png' width='800'>
<br/>

### UDP：把数据包送达应用程序

IP 是非常底层的协议，只负责把数据包传送给对方电脑，但对方电脑不知道把数据包交给哪个程序，因此，需要基于IP之上，开发能和应用打交道的协议，最常见的是“用户数据包协议”，简称UDP。

UDP 中一个最重要的信息是端口号，端口号其实就是一个数字，每个想访问网络的程序都需要绑定一个端口号。

通过端口号 UDP 就能把指定的数据包发送给指定的程序了，所以IP 通过 IP 地址信息把数据包发送给指定的电脑，而 UDP 通过端口号把数据包分发给正确的程序。

和 IP 头一样，端口号会被装进 UDP 头里面，UDP 头再和原始数据包合并组成新的 UDP 数据包。UDP 头中除了目的端口，还有源端口号等信息。

为了支持 UDP 协议，我把前面的三层结构扩充为四层结构，在网络层和上层之间增加了传输层，如下图所示：

<br/>
<img src='../../images/230.png' width='800'>
<br/>

在使用 UDP 发送数据时，有各种因素会导致数据包出错，虽然 UDP 可以校验数据是否正确，但是对于错误的数据包，UDP 并不提供重发机制，只是丢弃当前的包，而且 UDP 在发送之后也无法知道是否能达到目的地。

虽说UDP 不能保证数据可靠性，但是传输速度却非常快，所以 UDP 会应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等。

### TCP：把数据完整地送达应用程序

UDP 来传输会存在两个问题：

- 数据包在传输过程中容易丢失；
- 大文件会被拆分成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而 UDP 协议并不知道如何组装这些数据包，从而把这些数据包还原成完整的文件。

基于这两个问题，我们引入 TCP 了。TCP（传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。相对于 UDP，TCP 有下面两个特点:

- 对于数据包丢失的情况，TCP 提供重传机制；
- TCP 引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。

和 UDP 头一样，TCP 头除了包含了目标端口和本机端口号外，还提供了用于排序的序列号，以便接收端通过序号来重排数据包。

下面看看 TCP 下的单个数据包的传输流程：

<br/>
<img src='../../images/231.png' width='800'>
<br/>

通过上图你应该可以了解一个数据包是如何通过 TCP 来传输的。TCP 单个数据包的传输流程和 UDP 流程差不多，不同的地方在于，通过 TCP 头的信息保证了一块大的数据传输的完整性。

下面我们再看下完整的 TCP 连接过程，通过这个过程你可以明白 TCP 是如何保证重传机制和数据包的排序功能的。

从下图可以看出，一个完整的 TCP 连接的生命周期包括了“建立连接”“传输数据”和“断开连接”三个阶段。


<br/>
<img src='../../images/232.png' width='800'>
<br/>

- 首先，建立连接阶段。这个阶段是通过“三次握手”来建立客户端和服务器之间的连接。TCP 提供面向连接的通信传输。面向连接是指在数据通信开始之前先做好两端之间的准备工作。所谓三次握手，是指在建立一个 TCP 连接时，客户端和服务器总共要发送三个数据包以确认连接的建立。
- 其次，传输数据阶段。在该阶段，接收端需要对每个数据包进行确认操作，也就是接收端在接收到数据包之后，需要发送确认数据包给发送端。所以当发送端发送了一个数据包之后，在规定时间内没有接收到接收端反馈的确认消息，则判断为数据包丢失，并触发发送端的重发机制。同样，一个大的文件在传输过程中会被拆分成很多小的数据包，这些数据包到达接收端后，接收端会按照 TCP 头中的序号为其排序，从而保证组成完整的数据。
- 最后，断开连接阶段。数据传输完毕之后，就要终止连接了，涉及到最后一个阶段“四次挥手”来保证双方都能断开连接。

到这里你应该就明白了，TCP 为了保证数据传输的可靠性，牺牲了数据包的传输速度，因为“三次握手”和“数据包校验机制”等把传输过程中的数据包的数量提高了一倍。

### 总结

- 互联网中的数据是通过数据包来传输的，数据包在传输过程中容易丢失或出错。
- IP 负责把数据包送达目的主机。
- UDP 负责把数据包送达具体应用。
- 而 TCP 保证了数据完整地传输，它的连接可分为三个阶段：建立连接、传输数据和断开连接。

其实了解 TCP 协议，是为了全方位了解 HTTP，包括其实际功能和局限性，之后才会更加深刻地理解为什么要推出 HTTP/2，以及为什么要推出 QUIC 协议，也就是未来的 HTTP/3。这是一个由浅入深、循序渐进的过程，我希望你能稳扎稳打，学好这每一步、每一个协议，后面“水到自然渠成”。

<br/>

## 03丨HTTP请求流程：为什么很多站点第二次打开速度会很快？

HTTP 协议，是建立在 TCP 连接基础之上的。HTTP 是一种允许浏览器向服务器获取资源的协议

这篇文章，我将通过分析一个 HTTP 请求过程中每一步的状态来带你了解完整的 HTTP 请求过程。

### 浏览器端发起 HTTP 请求流程

#### 1 构建请求

首先，浏览器构建请求行信息（如下所示），构建好后，浏览器准备发起网络请求。

```http
GET /index.html HTTP1.1
```

#### 2 查找缓存

在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。

其中，浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。

当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请求，而不会再去源服务器重新下载。这样做的好处有：

- 缓解服务器端压力，提升性能（获取资源的耗时更短了）；
- 对于网站来说，缓存是实现快速资源加载的重要组成部分。

当然，如果缓存查找失败，就会进入网络请求过程了。

#### 准备 IP 地址和端口

在了解网络请求之前，我们需要先看看 HTTP 和 TCP 的关系。

因为浏览器使用 HTTP 协议作为应用层协议，用来封装请求的文本信息；

并使用 TCP/IP 作传输层协议将它发到网络上

所以在 HTTP 工作开始之前，浏览器需要通过 TCP 与服务器建立连接。也就是说 HTTP 的内容是通过 TCP 的传输数据阶段来实现的，你可以结合下图更好地理解这二者的关系。

<br/>
<img src='../../images/233.png' width='800'>
<br/>

这里我们需要思考几个问题：

- HTTP网络请求的第一步做什么？和服务器建立TCP连接
- 那建立连接的信息都有了吗？需要IP地址和端口号
- 如何获取IP地址和端口号呢？URL+DNS（DNS可以做缓存），端口号默认80

#### 等待 TCP 队列

Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。

当然，如果当前请求数量少于 6，会直接进入下一步，建立 TCP 连接。

#### 建立 TCP 连接

#### 发送 HTTP 请求

一旦建立了 TCP 连接，浏览器就可以和服务器进行通信了。而 HTTP 中的数据正是在这个通信过程中传输的。

你可以结合下图来理解，浏览器是如何发送请求信息给服务器的。234

<br/>
<img src='../../images/234.png' width='800'>
<br/>

首先浏览器会向服务器发送请求行，它包括了请求方法、请求 URI 和 HTTP 版本协议。

发送请求行，就是告诉服务器浏览器需要什么资源

在浏览器发送请求行命令之后，还要以请求头形式发送其他一些信息，把浏览器的一些基础信息告诉服务器。比如包含了浏览器所使用的操作系统、浏览器内核等信息，以及当前请求的域名信息、浏览器端的 Cookie 信息，等等。

### 服务器端处理 HTTP 请求流程

历经千辛万苦，HTTP 的请求信息终于被送达了服务器。接下来，服务器会根据浏览器的请求信息来准备相应的内容。

#### 返回请求

一旦服务器处理结束，便可以返回数据给浏览器了。

<br/>
<img src='../../images/235.png' width='800'>
<br/>

首先服务器会返回响应行，包括协议版本和状态码。

并不是所有的请求都可以被服务器处理的，那么一些无法处理或者处理出错的信息，怎么办呢？服务器会通过请求行的状态码来告诉浏览器它的处理结果

随后，正如浏览器会随同请求发送请求头一样，服务器也会随同响应向浏览器发送响应头。响应头包含了服务器自身的一些信息，比如服务器生成返回数据的时间、返回的数据类型（JSON、HTML、流媒体等类型），以及服务器要在客户端保存的 Cookie 等信息。

发送完响应头后，服务器就可以继续发送响应体的数据，通常，响应体就包含了 HTML 的实际内容。

以上这些就是服务器响应浏览器的具体过程。

#### 断开连接

通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在其头信息中加入了：

```http
Connection:Keep-Alive
```

保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。

### 问题解答

#### 为什么很多站点第二次打开速度会很快？

DNS 缓存和页面资源缓存

<br/>
<img src='../../images/236.png' width='800'>
<br/>

#### 登录状态是如何保持的？

简单地说，如果服务器端发送的响应头内有 Set-Cookie 的字段，那么浏览器就会将该字段的内容保持到本地。

当下次客户端再往该服务器发送请求时，客户端会自动在请求头中加入 Cookie 值后再发送出去。

服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到该用户的状态信息。

### 总结

HTTP 请求所经历的各个阶段:

<br/>
<img src='../../images/237.png' width='800'>
<br/>

从图中可以看到，浏览器中的 HTTP 请求从发起到结束一共经历了如下八个阶段：

- 构建请求
- 查找缓存
- 准备 IP 和端口
- 等待 TCP 队列
- 建立 TCP 连接
- 发起 HTTP 请求
- 服务器处理请求
- 服务器返回请求和断开连接

### 学习技巧

在学习过程中，你也要学会提问，通过最终要做什么和现在有什么，去一步步分析并提出一些问题，让疑问带领着你去学习，抓住几个本质的问题就可以学透相关知识点，让你能站在更高维度去查看整体框架。希望它能成为你的一个学习技巧吧！

<br>

## 04丨导航流程：从输入URL到页面展示，这中间发生了什么？

从输入 URL 到页面展示完整流程示意图

<br/>
<img src='../../images/238.png' width='900'>
<br/>

这个过程需要浏览器进程、渲染进程和网络进程的配合，先回顾下它们的主要职责：

- 浏览器进程：主要负责用户交互、子进程管理和文件储存等功能
- 网络进程：网络下载
- 渲染进程：解析页面

结合上图，整个流程的核心节点是：

- 首先，用户从浏览器进程里输入请求信息；
- 然后，网络进程发起 URL 请求；
- 服务器响应 URL 请求之后，浏览器进程就又要开始准备渲染进程了；
- 渲染进程准备好之后，需要先向渲染进程提交页面数据，我们称之为提交文档阶段；
- 渲染进程接收完文档信息之后，便开始解析页面和加载子资源，完成页面的渲染。

这其中，用户发出 URL 请求到页面开始解析的这个过程，就叫做导航。

### 1. 用户输入

当用户在地址栏中输入一个查询关键字时，地址栏会判断输入的关键字是搜索内容，还是请求的 URL。

- 如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 URL。
- 如果判断输入内容符合 URL 规则，比如输入的是 time.geekbang.org，那么地址栏会根据规则，把这段内容加上协议，合成为完整的 URL，如 https://time.geekbang.org。

当浏览器刚开始加载一个地址之后，标签页上的图标便进入了加载状态。但此时图中页面显示的依然是之前打开的页面内容。因为需要等待提交文档阶段，页面内容才会被替换。

### 2. URL 请求过程

接下来，便进入了页面资源请求过程。

这时，浏览器进程会通过进程间通信（IPC）把 URL 请求发送至网络进程，网络进程接收到 URL 请求后，会在这里发起真正的 URL 请求流程。

那具体流程是怎样的呢？

首先，网络进程会查找本地缓存是否缓存了该资源。

如果有缓存资源，那么直接返回资源给浏览器进程；

如果在缓存中没有查找到资源，那么直接进入网络请求流程。

这请求前的第一步是要进行 DNS 解析，以获取请求域名的服务器 IP 地址。如果请求协议是 HTTPS，那么还需要建立 TLS 连接。

接下来就是利用 IP 地址和服务器建立 TCP 连接。

连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。

服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给网络进程。

等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了。

#### 重定向

在导航过程中，如果服务器响应行的状态码包含了 301、302 一类的跳转信息，浏览器会跳转到新的地址继续导航；

如果响应行是 200，那么表示浏览器可以继续处理该请求。

#### 响应数据类型处理

服务器通过 Content-Type 告诉浏览器服务器返回的响应体数据是什么类型，然后浏览器会根据 Content-Type 的值来决定如何显示响应体的内容。

不同 Content-Type 的后续处理流程也截然不同。

如果 Content-Type 字段的值被浏览器判断为下载类型，那么该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航流程就此结束。

但如果是HTML，那么浏览器则会继续进行导航流程。由于 Chrome 的页面渲染是运行在渲染进程中的，所以接下来就需要准备渲染进程了。

### 3. 准备渲染进程

默认情况下，Chrome 会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。

总结来说，打开一个新页面采用的渲染进程策略就是：

- 通常情况下，打开新的页面都会使用单独的渲染进程；
- 如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么 B 页面复用 A 页面的渲染进程；如果是其他情况，浏览器进程则会为 B 创建一个新的渲染进程。

渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。

### 4. 提交文档

首先要明确一点，这里的“文档”是指 URL 请求的响应体数据。

- “提交文档”的消息是由浏览器进程发出的，渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”。
- 等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程。
- 浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。

<br/>
<img src='../../images/239.png' width='800'>
<br/>

这也就解释了为什么在浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面。

到这里，一个完整的导航流程就“走”完了，这之后就要进入渲染阶段了。

### 5. 渲染阶段

一旦文档被提交，渲染进程便开始页面解析和子资源加载了

一旦页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画。

<br/>
<img src='../../images/240.png' width='800'>
<br/>

至此，一个完整的页面就生成了。那文章开头的“从输入 URL 到页面展示，这中间发生了什么？”这个过程极其“串联”的问题也就解决了。

<br>

## 05丨渲染流程（上）：HTML、CSS和JavaScript，是如何变成页面的？

由于渲染机制过于复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的 HTML 经过这些子阶段，最后输出像素。

我们把这样的一个处理流程叫做渲染流水线，其大致流程如下图所示：

<br/>
<img src='../../images/241.png' width='800'>
<br/>

按照渲染的时间顺序，流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、栅格化和合成。

在介绍每个阶段的过程中，你应该重点关注以下三点内容：

- 开始每个子阶段都有其输入的内容；
- 然后每个子阶段有其处理过程；
- 最终每个子阶段会生成输出内容。

理解了这三部分内容，能让你更加清晰地理解每个子阶段。

### 构建 DOM 树

浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。

<br/>
<img src='../../images/242.png' width='800'>
<br/>

现在我们已经生成 DOM 树了，但是 DOM 节点的样式我们依然不知道，要让 DOM 节点拥有正确的样式，这就需要样式计算了。

### 样式计算

样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成。

#### 1. 把 CSS 转换为浏览器能够理解的结构

CSS 样式来源主要有三种：

- 通过 link 引用的外部 CSS 文件
- `<style>`标记内的 CSS
- 元素的 style 属性内嵌的 CSS

和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。

<br/>
<img src='../../images/243.png' width='800'>
<br/>

#### 2. 转换样式表中的属性值，使其标准化

现在我们已经把现有的 CSS 文本转化为浏览器可以理解的结构了，那么接下来就要对其进行属性值的标准化操作。

em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。

<br/>
<img src='../../images/244.png' width='800'>
<br/>

#### 3. 计算出 DOM 树中每个节点的具体样式

现在样式的属性已被标准化了，接下来就需要计算 DOM 树中每个节点的样式属性了，如何计算呢？

这就涉及到 CSS 的继承规则和层叠规则了。

首先是 CSS 继承。CSS 继承就是每个 DOM 节点都包含有父节点的样式。

<br/>
<img src='../../images/245.png' width='800'>
<img src='../../images/246.png' width='800'>
<br/>

然后，是CSS 样式层叠。层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。它在 CSS 处于核心地位，CSS 的全称“层叠样式表”正是强调了这一点。

总之，样式计算阶段的目的是为了计算出 DOM 节点中每个元素的具体样式，在计算过程中需要遵守 CSS 的继承和层叠两个规则。这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 ComputedStyle 的结构内。

<br/>
<img src='../../images/247.png' width='800'>
<br/>

### 布局阶段

现在，我们有 DOM 树和 DOM 树中元素的样式，但这还不足以显示页面，因为我们还不知道 DOM 元素的几何位置信息。

那么接下来就需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。

Chrome 在布局阶段需要完成两个任务：创建布局树和布局计算。

#### 1. 创建布局树

你可能注意到了 DOM 树还含有很多不可见的元素，比如 head 标签，还有使用了 display:none 属性的元素。

所以在显示之前，我们还要额外地构建一棵只包含可见元素布局树。

<br/>
<img src='../../images/248.png' width='800'>
<br/>

从上图可以看出，DOM 树中所有不可见的节点都没有包含到布局树中。

为了构建布局树，浏览器大体上完成了下面这些工作：

- 遍历 DOM 树中的所有可见节点，并把这些节点加到布局中；
- 而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，再比如 body.p.span 这个元素，因为它的属性包含 dispaly:none，所以这个元素也没有被包进布局树。

#### 2. 布局计算

现在我们有了一棵完整的布局树。那么接下来，就要计算布局树节点的坐标位置了。

后面章节中我再做详细的介绍。

在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以布局树既是输入内容也是输出内容，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。

针对这个问题，Chrome 团队正在重构布局代码，下一代布局系统叫 LayoutNG，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单。

### 总结

<br/>
<img src='../../images/249.png' width='800'>
<br/>

从图中可以看出，本节内容我们介绍了渲染流程的前三个阶段：DOM 生成、样式计算和布局。要点可大致总结为如下：

- 浏览器不能直接理解 HTML 数据，所以第一步需要将其转换为浏览器能够理解的 DOM 树结构；
- 生成 DOM 树后，还需要根据 CSS 样式表，来计算出 DOM 树所有节点的样式；
- 最后计算 DOM 元素的布局信息，使其都保存在布局树中。

到这里我们的每个节点都拥有了自己的样式和布局信息，那么后面几个阶段就要利用这些信息去展示页面了，由于篇幅限制，剩下的这些阶段我会在下一篇文章中介绍。

<br>

## 06丨渲染流程（下）：HTML、CSS和JavaScript，是如何变成页面的？

前三个阶段的主要内容：

- 在 HTML 页面内容被提交给渲染引擎之后，渲染引擎首先将 HTML 解析为浏览器可以理解的 DOM；
- 然后根据 CSS 样式表，计算出 DOM 树所有节点的样式；
- 接着又计算每个元素的几何坐标位置，并将这些信息保存在布局树中。

这篇文章接着讲解渲染流水线后面的阶段。

### 分层

我们有了布局树，而且每个元素的具体位置信息都计算出来了，那么接下来是不是就要开始着手绘制页面了？

答案依然是否定的。

因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树。

如果你熟悉 PS，相信你会很容易理解图层的概念，正是这些图层叠加在一起构成了最终的页面图像。

要想直观地理解什么是图层，你可以打开 Chrome 的“开发者工具”，选择“Layers”标签，就可以可视化页面的分层情况，如下图所示：

<br/>
<img src='../../images/250.png' width='800'>
<br/>

浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。

下面我们再来看看这些图层和布局树节点之间的关系，如文中图所示：

<br/>
<img src='../../images/251.png' width='800'>
<br/>

通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。

如上图中的 span 标签没有专属图层，那么它们就从属于它们的父节点图层。但不管怎样，最终每一个节点都会直接或者间接地从属于一个层。

那么需要满足什么条件，渲染引擎才会为特定的节点创建新的层呢？通常满足下面两点中任意一点的元素就可以被提升为单独的一个图层。

第一点，拥有层叠上下文属性的元素会被提升为单独的一层。

明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性。

若你想要了解更多层叠上下文的知识，你可以[参考这篇文章](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context)。

第二点，需要剪裁（clip）的地方也会被创建为图层

出现这种裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。你可以参考下图：

<br/>
<img src='../../images/252.png' width='800'>
<br/>

所以说，元素有了层叠上下文的属性或者需要被剪裁，满足这任意一点，就会被提升成为单独一层。

### 图层绘制

在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制。

渲染引擎会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表，如下图所示：

<br/>
<img src='../../images/253.png' width='800'>
<br/>

从图中可以看出，绘制列表中的指令其实非常简单，就是让其执行一个简单的绘制操作

而绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。

所以在图层绘制阶段，输出的内容就是这些待绘制列表。

### 栅格化（raster）操作

绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。

你可以结合下图来看下渲染主线程和合成线程之间的关系：

<br/>
<img src='../../images/254.png' width='800'>
<br/>

当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程，那么接下来合成线程是怎么工作的呢？

那我们得先来看看什么是视口，你可以参看下图：

<br/>
<img src='../../images/255.png' width='800'>
<br/>

通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口（viewport）。

在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。

基于这个原因，合成线程会将图层划分为图块（tile），这些图块的大小通常是 256x256 或者 512x512，如下图所示：

<br/>
<img src='../../images/256.png' width='800'>
<br/>

然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。

所谓栅格化，是指将图块转换为位图。

而图块是栅格化执行的最小单位。

渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的，运行方式如下图所示：

<br/>
<img src='../../images/257.png' width='800'>
<br/>

通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。

相信你还记得，GPU 操作是运行在 GPU 进程中，如果栅格化操作使用了 GPU，那么最终生成位图的操作是在 GPU 中完成的，这就涉及到了跨进程操作。具体形式你可以参考下图：

<br/>
<img src='../../images/258.png' width='800'>
<br/>

从图中可以看出，渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中。

### 合成和显示

一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。

浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。

到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面了。

### 渲染流水线大总结

现在已经分析完了整个渲染流程，从 HTML 到 DOM、样式计算、布局、图层、绘制、光栅化、合成和显示。下面我用一张图来总结下这整个渲染流程：

<br/>
<img src='../../images/259.png' width='800'>
<br/>

- 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。
- 渲染引擎将 CSS 样式表转化为浏览器可以理解的styleSheets，计算出 DOM 节点的样式。
- 创建布局树，并计算元素的布局信息。
- 对布局树进行分层，并生成分层树。
- 为每个图层生成绘制列表，并将其提交到合成线程。
- 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
- 合成线程发送绘制图块命令DrawQuad给浏览器进程。
- 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。

### 相关概念

有了上面介绍渲染流水线的基础，我们再来看看三个和渲染流水线相关的概念——“重排”“重绘”和“合成”。理解了这三个概念对于你后续 Web 的性能优化会有很大帮助。

#### 1. 更新了元素的几何属性（重排）

<br/>
<img src='../../images/260.png' width='800'>
<br/>

从上图可以看出，如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。

无疑，重排需要更新完整的渲染流水线，所以开销也是最大的。

#### 2. 更新元素的绘制属性（重绘）

比如通过 JavaScript 更改某些元素的背景颜色，渲染流水线会怎样调整呢？你可以参考下图：

<br/>
<img src='../../images/261.png' width='800'>
<br/>

从图中可以看出，如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。

相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。

#### 3. 直接合成阶段

那如果你更改一个既不要布局也不要绘制的属性，会发生什么变化呢？渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成。具体流程参考下图：

<br/>
<img src='../../images/262.png' width='800'>
<br/>

在上图中，我们使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。







- 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。
- 渲染引擎将 CSS 样式表转化为浏览器可以理解的styleSheets，计算出 DOM 节点的样式。
- 创建布局树，并计算元素的布局信息。
- 对布局树进行分层，并生成分层树。
- 为每个图层生成绘制列表，并将其提交到合成线程。
- 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
- 合成线程发送绘制图块命令DrawQuad给浏览器进程。
- 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。


HTML、CSS => 渲染进程 => 布局树

布局树 => 分层 => 分层树

图层 => 合成 => 绘制列表

图层 => 栅格化 => 位图

位图 => 浏览器进程 => 页面


## 渲染小结

<br/>
<img src='../../images/263.png' width='800'>
<br/>

从图中可以看出，左边输入的是 HTML、CSS、JavaScript 数据，这些数据经过中间渲染模块的处理，最终输出为屏幕上的像素。

渲染模块是个流水线，一共经历八个阶段。

- 构建 DOM 树
- 样式计算
- 布局阶段
- 分层
- 绘制
- 分块
- 光栅化
- 合成和显示

每个阶段重点关注以下三点内容：

- 开始每个子阶段都有其输入的内容；
- 然后每个子阶段有其处理过程；
- 最终每个子阶段会生成输出内容。

一、构建 DOM 树

- 输入：HTML
- 处理：HTML 解析器解析
- 输出：生成 DOM 树

<br/>
<img src='../../images/264.png' width='800'>
<br/>

二、样式计算

- 输入：CSS
- 处理：生成 styleSheets，进行属性值的标准化操作，计算出 DOM 树中每个节点的具体样式（涉及到 CSS 的继承规则和层叠规则）
- 输出：每个元素的具体样式

<br/>
<img src='../../images/265.png' width='800'>
<br/>

三、布局阶段

- 输入：DOM 树和 DOM 树中元素的样式
- 处理：创建一棵只包含可见元素的布局树，计算可见元素的几何位置
- 输出：布局树

<br/>
<img src='../../images/266.png' width='800'>
<br/>

四、分层

- 输入：布局树
- 处理：渲染引擎为特定的节点生成专用的图层，并生成一棵对应的图层树
- 输出：图层树

<br/>
<img src='../../images/267.png' width='800'>
<br/>

五、绘制

- 输入：图层树
- 处理：渲染引擎把每一个图层的绘制拆分成很多小的绘制指令
- 输出：待绘制指令列表

<br/>
<img src='../../images/268.png' width='800'>
<br/>

六、分块

- 输入：图层的绘制列表
- 处理：优先绘制视口，合成线程会将图层划分为图块
- 输出：图块，这些图块的大小通常是 256x256 或者 512x512
- 位置：渲染进程的合成线程中

<br/>
<img src='../../images/269.png' width='800'>
<br/>

七、栅格化

- 输入：图块
- 处理：合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的
- 输出：位图
- 位置：渲染进程栅格化的线程池，通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。

<br/>
<img src='../../images/270.png' width='800'>
<br/>

八、合成和显示

- 输入：位图
- 处理：合成线程发送绘制图块命令DrawQuad给浏览器进程，浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。
- 输出：显示页面


一个完整的渲染流程大致可总结为如下：

<br/>
<img src='../../images/271.png' width='800'>
<br/>

- 渲染进程将 HTML 内容转换为能够读懂的DOM 树结构。
- 渲染引擎将 CSS 样式表转化为浏览器可以理解的styleSheets，计算出 DOM 节点的样式。
- 创建布局树，并计算元素的布局信息。
- 对布局树进行分层，并生成分层树。
- 为每个图层生成绘制列表，并将其提交到合成线程。
- 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
- 合成线程发送绘制图块命令DrawQuad给浏览器进程。
- 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。

# 浏览器中的JavaScript执行机制
## 07丨变量提升：JavaScript代码是按顺序执行的吗？
## 08丨调用栈：为什么JavaScript代码会出现栈溢出？
## 09丨块级作用域：var缺陷以及为什么要引入let和const？
## 10丨作用域链和闭包：代码中出现相同的变量，JavaScript引擎是如何选择的？
## 11丨this：从JavaScript执行上下文的视角讲清楚this

# V8工作原理
## 12丨栈空间和堆空间：数据是如何存储的？
## 13丨垃圾回收：垃圾数据是如何自动回收的？
## 14丨编译器和解释器：V8是如何执行一段JavaScript代码的？

# 浏览器中的页面循环系统
## 15丨消息队列和事件循环：页面是怎么“活”起来的？
## 16丨WebAPI：setTimeout是如何实现的？
## 17丨WebAPI：XMLHttpRequest是怎么实现的？
## 18丨宏任务和微任务：不是所有任务都是一个待遇
## 19丨Promise：使用Promise，告别回调函数
## 20丨async-await：使用同步的方式去写异步代码

# 浏览器中的页面
## 21丨Chrome开发者工具：利用网络面板做性能分析
## 22丨DOM树：JavaScript是如何影响DOM树构建的？
## 23丨渲染流水线：CSS如何影响首次加载时的白屏时间？
## 24丨分层和合成机制：为什么CSS动画比JavaScript高效？
## 25丨页面性能：如何系统地优化页面？
## 26丨虚拟DOM：虚拟DOM和实际的DOM有何不同？
## 27丨渐进式网页应用（PWA）：它究竟解决了Web应用的哪些问题？
## 28丨WebComponent：像搭积木一样构建Web应用

# 浏览器中的网络
## 29丨HTTP-1：HTTP性能优化
## 30｜HTTP-2：如何提升网络速度？
## 31｜HTTP-3：甩掉TCP、TLS的包袱，构建高效网络

# 浏览器安全
## 32丨同源策略：为什么XMLHttpRequest不能跨域请求资源？
## 33丨跨站脚本攻击（XSS）：为什么Cookie中有HttpOnly属性？
## 34丨CSRF攻击：陌生链接不要随便点
## 35丨安全沙箱：页面和系统之间的隔离墙
## 36丨HTTPS：让数据传输更安全
