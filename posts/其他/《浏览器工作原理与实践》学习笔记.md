

# 导学
## 00开篇词丨参透了浏览器的工作原理，你就能解决80%的前端难题

### 浏览器的地位
浏览器是披着应用外衣的小型操作系统。

未来的浏览器，有三个大的进化路线：
1. 应用程序 Web 化

视频、音频、游戏几大核心场景也都在往 Web 的使用场景切换

2. Web 应用移动化

Google 推出了 PWA 方案来整合 Web 和本地程序各自的优势

3. Web 操作系统化

一是利用 Web 技术构建一个纯粹的操作系统，如 ChromeOS；二是浏览器的底层结构往操作系统架构方向发展，比如：

- Chrome 朝着 SOA 的方向演化，未来很多模块都会以服务的形式提供给上层应用使用；
- 在浏览器中引入多种编程语言的支持，比如新支持的 WebAssembly；
- 简化渲染流程，使得渲染过程更加直接高效；
- 加大对系统设备特性的支持；
- 提供对复杂 Web 项目开发的支持。

也就是说，浏览器已经逐步演化成了操作系统之上的“操作系统”。
### 为什么需要学习浏览器工作原理？

1. 准确评估 Web 开发项目的可行性

随着 Web 特性的极大丰富和浏览器性能的提升，越来越多的项目可以用 Web 来开发。所以，了解浏览器是如何工作的，能够让你更加准确地决策是否可以采用 Web 来开发项目。

2. 从更高维度审视页面

作为一名合格的开发者，你还要具备一项重要的技能，那就是：要能站在用户体验角度来考虑页面性能。

页面加载时长、用户交互反馈时长、Web 动画中的帧数都决定了用户体验的流畅度，并最终决定了用户体验的效果。

但通常，这些指标是由一系列的复杂因素导致的。如果你要开发流畅的页面，或者诊断 Web 页面中的性能问题，那你就需要了解 URL 是怎么变成页面的，只有弄懂这些之后，你才可以站在全局的角度定位问题或者写出高效的代码。

如果你把浏览器当成黑盒处理，也可以写前端代码，也可以使用很多最佳实践的策略来优化代码，这就如同不了解操作系统的工作原理同样可以在操作系统上写应用一样。

但如果你理解了这个黑盒子是如何工作的，那情况就不同了。你可以站在更高的维度审视你的项目，通过全视野快速定位项目中不合理的地方。比如，首屏的显示就涉及了 DNS、HTTP、DOM 解析、CSS 阻塞、JavaScript 阻塞等技术因素，其中一项没处理好就可能导致整个页面的延时。

而如果你了解了浏览器的工作原理，更加可以把这些知识点串成线，连成网，最终形成自己的知识体系，练就像专家一样思考问题、解决问题的能力。

3. 在快节奏的技术迭代中把握本质

现阶段，浏览器功能以及整个前端的开发环境，不足以支撑日益增长的需求，所以“变化”是这段时期的主旋律。这种变化直接扩大了前端工程师的知识半径，这也导致很多前端开发工程师变成了爆栈工程师。

虽然前端技术变化快，不过我觉得这里有更大的机遇，谁能快速抓住变化，谁就能收获这波变化带来的红利。

我相信，随着脚本执行效率的提高、页面渲染性能的提升和开发工具链的完善，接下来的前端会进入一个相对平稳的阶段。通俗地理解就是：等到核心技术足以支撑核心需求，那么前端生态会进入一个相对稳定的状态。

如果了解了浏览器的工作机制，那么你可以梳理出来前端技术的发展脉络，更加深刻地理解当前的技术，同时你也会清楚其不足之处，以及演化方向。

### 前端技术的演进

前端技术是如何针对这些核心诉求做演进的？

首先是脚本执行速度问题。比如针对 JavaScript 设计缺陷和执行效率的问题，可以从以下两个途径去解决：

- 不断修订和更新语言本身，这样你就应该知道 ES6、ES7、ES8，或者 TypeScript 出现的必要性。这种修订对目前生态环境的改动是最小的，所以推行起来会比较容易。
- 颠覆性地使用新的语言，这就是 WebAssembly 出现的原因。WebAssembly 需要经过编译器编译，所以体积小、执行速度快，使用它能大幅提升语言的执行效率，但是语言本身的完善，和生态的构建都是需要花很长时间来打造的。

其次是前端模块化开发。比如，随着 Web 应用在各个领域的深入，Web 工程的复杂程度也越来越高，这就产生了模块化开发的需求，于是相应出现了 WebComponents 标准。我们所熟悉的 React 和 Vue 都在渐进地适应 WebComponents 标准，同时各种前端框架的最佳实践也会反过来影响 WebComponents 标准的制定。

如果理解了浏览器工作原理，那么你会对 WebComponents 中涉及的 Shawdow DOM、HTML Templates 等技术有更深刻的理解。

最后是渲染效率问题。同样，如果理解浏览器的渲染流程，那么你应该知道目前页面的渲染依然存在很大缺陷，然后你就清楚如何避开这些问题，从而开发出更加高效的 Web 应用。与此同时，Chrome 团队也在着手改善这些缺陷，比如正在开发的下一代布局方案 LayoutNG，还有渲染瘦身方案 Slim Paint，其目的都是让渲染变得更加简单和高效。

综上可以看出，触发这些改变的背后因素是当前技术制约了现实的需求，所以了解浏览器是如何工作的，能让你站在更高维度去理解前端。


# 宏观视角下的浏览器
## 01丨Chrome架构：仅仅打开了1个页面，为什么有4个进程？
## 02丨TCP协议：如何保证页面文件能被完整送达浏览器？
## 03丨HTTP请求流程：为什么很多站点第二次打开速度会很快？
## 04丨导航流程：从输入URL到页面展示，这中间发生了什么？
## 05丨渲染流程（上）：HTML、CSS和JavaScript，是如何变成页面的？
## 06丨渲染流程（下）：HTML、CSS和JavaScript，是如何变成页面的？
# 浏览器中的JavaScript执行机制
## 07丨变量提升：JavaScript代码是按顺序执行的吗？
## 08丨调用栈：为什么JavaScript代码会出现栈溢出？
## 09丨块级作用域：var缺陷以及为什么要引入let和const？
## 10丨作用域链和闭包：代码中出现相同的变量，JavaScript引擎是如何选择的？
## 11丨this：从JavaScript执行上下文的视角讲清楚this
# V8工作原理
## 12丨栈空间和堆空间：数据是如何存储的？
## 13丨垃圾回收：垃圾数据是如何自动回收的？
## 14丨编译器和解释器：V8是如何执行一段JavaScript代码的？
# 浏览器中的页面循环系统
## 15丨消息队列和事件循环：页面是怎么“活”起来的？
## 16丨WebAPI：setTimeout是如何实现的？
## 17丨WebAPI：XMLHttpRequest是怎么实现的？
## 18丨宏任务和微任务：不是所有任务都是一个待遇
## 19丨Promise：使用Promise，告别回调函数
## 20丨async-await：使用同步的方式去写异步代码
# 浏览器中的页面
## 21丨Chrome开发者工具：利用网络面板做性能分析
## 22丨DOM树：JavaScript是如何影响DOM树构建的？
## 23丨渲染流水线：CSS如何影响首次加载时的白屏时间？
## 24丨分层和合成机制：为什么CSS动画比JavaScript高效？
## 25丨页面性能：如何系统地优化页面？
## 26丨虚拟DOM：虚拟DOM和实际的DOM有何不同？
## 27丨渐进式网页应用（PWA）：它究竟解决了Web应用的哪些问题？
## 28丨WebComponent：像搭积木一样构建Web应用
# 浏览器中的网络
## 29丨HTTP-1：HTTP性能优化
## 30｜HTTP-2：如何提升网络速度？
## 31｜HTTP-3：甩掉TCP、TLS的包袱，构建高效网络
# 浏览器安全
## 32丨同源策略：为什么XMLHttpRequest不能跨域请求资源？
## 33丨跨站脚本攻击（XSS）：为什么Cookie中有HttpOnly属性？
## 34丨CSRF攻击：陌生链接不要随便点
## 35丨安全沙箱：页面和系统之间的隔离墙
## 36丨HTTPS：让数据传输更安全


